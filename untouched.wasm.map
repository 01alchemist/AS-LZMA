{"version":3,"sources":["~lib/internal/allocator.ts","~lib/allocator/arena.ts","src/lzma/range-decoder.ts","src/lzma/lzma.ts","src/lzma/lzma-decoder.ts","~lib/internal/arraybuffer.ts","~lib/internal/string.ts","~lib/internal/number.ts","~lib/builtins.ts","~lib/array.ts","~lib/memory.ts","~lib/internal/memory.ts","src/lzma/bit-tree-decoder.ts","src/lzma/len-decoder.ts","src/lzma/out-window.ts","src/index.ts","~lib/internal/typedarray.ts"],"names":[],"mappings":"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","sourceRoot":"assemblyscript:///","sourceContents":["/** Number of alignment bits. */\n@inline export const AL_BITS: u32 = 3;\n/** Number of possible alignment values. */\n@inline export const AL_SIZE: usize = 1 << <usize>AL_BITS;\n/** Mask to obtain just the alignment bits. */\n@inline export const AL_MASK: usize = AL_SIZE - 1;\n/** Maximum 32-bit allocation size. */\n@inline export const MAX_SIZE_32: usize = 1 << 30; // 1GB\n","/**\n * Arena Memory Allocator\n *\n * Provides a `memory.reset` function to reset the heap to its initial state. A user has to make\n * sure that there are no more references to cleared memory afterwards. Always aligns to 8 bytes.\n *\n * @module std/assembly/allocator/arena\n *//***/\n\nimport { AL_MASK, MAX_SIZE_32 } from \"../internal/allocator\";\n\nvar startOffset: usize = (HEAP_BASE + AL_MASK) & ~AL_MASK;\nvar offset: usize = startOffset;\n\n// Memory allocator interface\n\n@global export function __memory_allocate(size: usize): usize {\n  if (size > MAX_SIZE_32) unreachable();\n  var ptr = offset;\n  var newPtr = (ptr + max<usize>(size, 1) + AL_MASK) & ~AL_MASK;\n  var pagesBefore = memory.size();\n  if (newPtr > <usize>pagesBefore << 16) {\n    let pagesNeeded = ((newPtr - ptr + 0xffff) & ~0xffff) >>> 16;\n    let pagesWanted = max(pagesBefore, pagesNeeded); // double memory\n    if (memory.grow(pagesWanted) < 0) {\n      if (memory.grow(pagesNeeded) < 0) {\n        unreachable(); // out of memory\n      }\n    }\n  }\n  offset = newPtr;\n  return ptr;\n}\n\n@global export function __memory_free(ptr: usize): void { /* nop */ }\n\n@global export function __memory_reset(): void {\n  offset = startOffset;\n}\n","/**\n * LZMA Decoder\n * @author Nidin Vinayakan\n */\nexport class RangeDecoder {\n    static kTopValue: u32 = 1 << 24\n\n    public inStream: Uint8Array\n    public corrupted: boolean\n\n    public in_pos: i32\n    private range: i32 //UInt32\n    private code: i32 //UInt32\n    private rangeI: i32 = 0\n    private codeI: i32 = 1\n    private loc1: i32 = 2\n    private loc2: i32 = 3\n    private U32: Uint32Array\n    private U16: u16[]\n\n    constructor() {\n        this.in_pos = 13\n    }\n    public isFinishedOK(): boolean {\n        return this.U32[this.codeI] == 0\n    }\n    public init(): void {\n        this.U32 = new Uint32Array(4)\n        this.U16 = new Array<u16>(4)\n        this.corrupted = false\n\n        if (this.inStream[this.in_pos++] != 0) {\n            this.corrupted = true\n        }\n\n        this.U32[this.rangeI] = 0xffffffff\n        this.U32[this.codeI] = 0\n\n        for (var i: i32 = 0; i < 4; i++) {\n            this.U32[this.codeI] = (this.U32[this.codeI] << 8) | this.inStream[this.in_pos++]\n        }\n\n        if (this.U32[this.codeI] == this.U32[this.rangeI]) {\n            this.corrupted = true\n        }\n    }\n\n    public normalize():void {\n        if (this.U32[this.rangeI] < RangeDecoder.kTopValue) {\n            this.U32[this.rangeI] <<= 8\n            this.U32[this.codeI] = (this.U32[this.codeI] << 8) | this.inStream[this.in_pos++]\n        }\n    }\n\n    public decodeDirectBits(numBits: i32): i32 {\n        this.U32[this.loc1] = 0 //UInt32\n        do {\n            this.U32[this.rangeI] >>>= 1\n            this.U32[this.codeI] -= this.U32[this.rangeI]\n            this.U32[this.loc2] = 0 - (this.U32[this.codeI] >>> 31)\n            this.U32[this.codeI] += this.U32[this.rangeI] & this.U32[this.loc2]\n\n            if (this.U32[this.codeI] == this.U32[this.rangeI]) {\n                this.corrupted = true\n            }\n\n            this.normalize()\n            this.U32[this.loc1] <<= 1\n            this.U32[this.loc1] += this.U32[this.loc2] + 1\n        } while (--numBits)\n        return this.U32[this.loc1]\n    }\n\n    public decodeBit(prob: u16[], index: i32): i32 {\n        this.U16[0] = prob[index]\n        //bound\n        this.U32[2] = (this.U32[0] >>> 11) * this.U16[0]\n        //var symbol:i32;\n        if (this.U32[1] < this.U32[2]) {\n            this.U16[0] += ((1 << 11) - this.U16[0]) >>> 5\n            this.U32[0] = this.U32[2]\n            this.U16[1] = 0\n        } else {\n            //v -= v >>> LZMA.kNumMoveBits;\n            this.U16[0] -= this.U16[0] >>> 5\n            this.U32[1] -= this.U32[2]\n            this.U32[0] -= this.U32[2]\n            this.U16[1] = 1\n        }\n        prob[index] = this.U16[0]\n        //this.normalize();\n        if (this.U32[0] < 16777216) {\n            this.U32[0] <<= 8\n            this.U32[1] = (this.U32[1] << 8) | this.inStream[this.in_pos++]\n        }\n        return this.U16[1]\n    }\n}\n","import \"allocator/arena\";\nimport { LzmaDecoder } from './lzma-decoder'\nimport { RangeDecoder } from './range-decoder'\n'use strict'\n/**\n * LZMA Decoder\n * @author Nidin Vinayakan\n */\n\nexport class LZMA {\n    static LZMA_DIC_MIN: u32 = 1 << 12\n    static LZMA_RES_ERROR: u32 = 0\n    static LZMA_RES_FINISHED_WITH_MARKER: u32 = 1\n    static LZMA_RES_FINISHED_WITHOUT_MARKER: u32 = 2\n    static kNumBitModelTotalBits: u16 = 11\n    static kNumMoveBits: u8 = 5\n    static PROB_INIT_VAL: u16 = (1 << LZMA.kNumBitModelTotalBits) / 2 //1024\n    static kNumPosBitsMax: u8 = 4\n\n    static kNumStates: i32 = 12\n    static kNumLenToPosStates: i32 = 4\n    static kNumAlignBits: i32 = 4\n    static kStartPosModelIndex: i32 = 4\n    static kEndPosModelIndex: i32 = 14\n    static kNumFullDistances: i32 = 1 << (LZMA.kEndPosModelIndex >>> 1)\n    static kMatchMinLen: i32 = 2\n\n    public decoder: LzmaDecoder\n    public data: Uint8Array\n\n    static INIT_PROBS(p: u16[]): void {\n        for (var i: i32 = 0; i < p.length; i++) {\n            p[i] = this.PROB_INIT_VAL\n        }\n    }\n    static BitTreeReverseDecode(probs: u16[], numBits: i32, rc: RangeDecoder, offset: i32 = 0): i32 {\n        var m: i32 = 1\n        var symbol: i32 = 0\n        for (var i: i32 = 0; i < numBits; i++) {\n            var bit: i32 = rc.decodeBit(probs, offset + m)\n            m <<= 1\n            m += bit\n            symbol |= bit << i\n        }\n        return symbol\n    }\n    constructor() {\n        this.decoder = new LzmaDecoder()\n    }\n    public decode(data: Uint8Array): Uint8Array {\n        this.data = data\n        //var header:Uint8Array = data.readUint8Array(13);\n        var header: Uint8Array = new Uint8Array(13)\n        var i: i32 //int\n        for (i = 0; i < 13; i++) {\n            header[i] = data[i]\n        }\n\n        this.decoder.decodeProperties(header)\n\n        //console.log(\"lc=\"+this.decoder.lc+\", lp=\"+this.decoder.lp+\", pb=\"+this.decoder.pb);\n        //console.log(\"Dictionary Size in properties = \"+this.decoder.dictSizeInProperties);\n        //console.log(\"Dictionary Size for decoding  = \"+this.decoder.dictSize);\n        //return this.ucdata;\n        var unpackSize: i32 = 0 //UInt64\n        var unpackSizeDefined: boolean = false\n        for (i = 0; i < 8; i++) {\n            var b: i32 = header[5 + i]\n            if (b != 0xff) {\n                unpackSizeDefined = true\n            }\n            unpackSize |= b << (8 * i)\n        }\n\n        this.decoder.markerIsMandatory = !unpackSizeDefined\n\n        /*if (unpackSizeDefined){\n                console.log(\"Uncompressed Size : \"+ unpackSize +\" bytes\");\n            }else{\n                console.log(\"End marker is expected\");\n            }*/\n        this.decoder.rangeDec.inStream = data\n        this.decoder.create()\n        // we support the streams that have uncompressed size and marker.\n        var res: i32 = this.decoder.decode(unpackSizeDefined, unpackSize) //int\n\n        //console.log(\"Read    \", this.decoder.rangeDec.in_pos);\n        //console.log(\"Written \", this.decoder.outWindow.out_pos);\n\n        if (res == LZMA.LZMA_RES_ERROR) {\n            throw 'LZMA decoding error'\n        } else if (res == LZMA.LZMA_RES_FINISHED_WITHOUT_MARKER) {\n            //console.log(\"Finished without end marker\");\n        } else if (res == LZMA.LZMA_RES_FINISHED_WITH_MARKER) {\n            if (unpackSizeDefined) {\n                if (this.decoder.outWindow.out_pos != unpackSize) {\n                    throw 'Finished with end marker before than specified size'\n                }\n                //console.log(\"Warning: \");\n            }\n            //console.log(\"Finished with end marker\");\n        } else {\n            throw 'Internal Error'\n        }\n\n        if (this.decoder.rangeDec.corrupted) {\n            // console.log('Warning: LZMA stream is corrupted')\n        }\n        return this.decoder.outWindow.outStream\n    }\n}\n","import { RangeDecoder } from './range-decoder';\nimport { OutWindow } from './out-window';\nimport { BitTreeDecoder } from './bit-tree-decoder';\nimport { LenDecoder } from './len-decoder';\nimport { LZMA } from './lzma';\n\n/**\n * LZMA Decoder\n * @author Nidin Vinayakan\n */\n\nexport class LzmaDecoder {\n    //Public\n    public markerIsMandatory: boolean\n    public rangeDec: RangeDecoder //RangeDecoder\n    public outWindow: OutWindow //OutWindow\n    public lc: i32\n    public pb: i32\n    public lp: u8 //unsigned byte\n    public dictSize: u32 //UInt32\n    public dictSizeInProperties: u8 //UInt32\n\n    //Private\n    private litProbs: u16[]\n\n    private posSlotDecoder: Array<BitTreeDecoder>\n    private alignDecoder: BitTreeDecoder\n    private posDecoders: u16[]\n\n    private isMatch: u16[]\n    private isRep: u16[]\n    private isRepG0: u16[]\n    private isRepG1: u16[]\n    private isRepG2: u16[]\n    private isRep0Long: u16[]\n\n    private lenDecoder: LenDecoder\n    private repLenDecoder: LenDecoder\n\n    //Local registers\n    private loc1: i32\n    private loc2: i32\n    private matchBitI: i32\n    private matchByteI: i32\n    private bitI: i32\n    private symbolI: i32\n    private prevByteI: i32\n    private litStateI: i32\n\n    constructor() {\n        this.posSlotDecoder = BitTreeDecoder.constructArray(6, LZMA.kNumLenToPosStates) //6\n        this.alignDecoder = new BitTreeDecoder(LZMA.kNumAlignBits)\n        this.posDecoders = new Array<u16>(1 + LZMA.kNumFullDistances - LZMA.kEndPosModelIndex)\n\n        this.isMatch = new Array<u16>(LZMA.kNumStates << LZMA.kNumPosBitsMax)\n        this.isRep = new Array<u16>(LZMA.kNumStates)\n        this.isRepG0 = new Array<u16>(LZMA.kNumStates)\n        this.isRepG1 = new Array<u16>(LZMA.kNumStates)\n        this.isRepG2 = new Array<u16>(LZMA.kNumStates)\n        this.isRep0Long = new Array<u16>(LZMA.kNumStates << LZMA.kNumPosBitsMax)\n\n        this.lenDecoder = new LenDecoder()\n        this.repLenDecoder = new LenDecoder()\n        this.rangeDec = new RangeDecoder()\n        this.outWindow = new OutWindow()\n    }\n\n    public init(): void {\n\n        this.initLiterals()\n        this.initDist()\n\n        LZMA.INIT_PROBS(this.isMatch)\n        LZMA.INIT_PROBS(this.isRep)\n        LZMA.INIT_PROBS(this.isRepG0)\n        LZMA.INIT_PROBS(this.isRepG1)\n        LZMA.INIT_PROBS(this.isRepG2)\n        LZMA.INIT_PROBS(this.isRep0Long)\n\n        this.lenDecoder.init()\n        this.repLenDecoder.init()\n    }\n    public create(): void {\n        this.outWindow.create(this.dictSize)\n        this.createLiterals()\n    }\n    //Private\n    private createLiterals(): void {\n        this.litProbs = new Array<u16>(0x300 << (this.lc + this.lp))\n    }\n    private initLiterals(): void {\n        var num: i32 = 0x300 << (this.lc + this.lp) //UInt32\n        for (var i: i32 = 0; i < num; i++) {\n            this.litProbs[i] = LZMA.PROB_INIT_VAL\n        }\n    }\n    private decodeLiteral(state:u8, rep0:u32): void {\n        //unsigned , UInt32\n        this.prevByteI = 0 //unsigned byte\n        if (!this.outWindow.isEmpty()) this.prevByteI = this.outWindow.getByte(1)\n\n        this.symbolI = 1\n        this.litStateI =\n            ((this.outWindow.totalPos & ((1 << this.lp) - 1)) << this.lc) +\n            (this.prevByteI >>> (8 - this.lc))\n        var probsOffset: i32 = (0x300 * this.litStateI) | 0\n\n        if (state >= 7) {\n            this.matchByteI = this.outWindow.getByte(rep0 + 1)\n            do {\n                this.matchBitI = (this.matchByteI >>> 7) & 1\n                this.matchByteI <<= 1\n                this.bitI = this.rangeDec.decodeBit(\n                    this.litProbs,\n                    probsOffset + ((1 + this.matchBitI) << 8) + this.symbolI,\n                )\n                this.symbolI = (this.symbolI << 1) | this.bitI\n                if (this.matchBitI != this.bitI) break\n            } while (this.symbolI < 0x100)\n        }\n        while (this.symbolI < 0x100) {\n            this.symbolI =\n                (this.symbolI << 1) |\n                this.rangeDec.decodeBit(this.litProbs, probsOffset + this.symbolI)\n        }\n        this.outWindow.putByte(this.symbolI - 0x100)\n    }\n\n    private decodeDistance(len: i32): i32 {\n        //unsigned byte\n        var lenState: i32 = len //unsigned byte\n        if (lenState > LZMA.kNumLenToPosStates - 1) lenState = LZMA.kNumLenToPosStates - 1\n\n        var posSlot = this.posSlotDecoder[lenState].decode(this.rangeDec) //unsigned byte\n        if (posSlot < 4) return posSlot\n\n        var numDirectBits = (posSlot >>> 1) - 1 //unsigned byte\n        this.loc1 = (2 | (posSlot & 1)) << numDirectBits //UInt32\n        if (posSlot < LZMA.kEndPosModelIndex) {\n            this.loc1 += LZMA.BitTreeReverseDecode(\n                this.posDecoders,\n                numDirectBits,\n                this.rangeDec,\n                this.loc1 - posSlot,\n            )\n        } else {\n            this.loc1 +=\n                this.rangeDec.decodeDirectBits(numDirectBits - LZMA.kNumAlignBits) << LZMA.kNumAlignBits\n            this.loc1 += this.alignDecoder.reverseDecode(this.rangeDec)\n        }\n        return this.loc1\n    }\n    private initDist(): void {\n        for (var i = 0; i < LZMA.kNumLenToPosStates; i++) {\n            this.posSlotDecoder[i].init()\n        }\n        this.alignDecoder.init()\n        LZMA.INIT_PROBS(this.posDecoders)\n    }\n    public decodeProperties(properties: Uint8Array): void {\n        var prop = new Uint8Array(4)\n        prop[0] = properties[0]\n        if (prop[0] >= 9 * 5 * 5) {\n            throw 'Incorrect LZMA properties'\n        }\n        prop[1] = prop[0] % 9\n        prop[0] /= 9\n        prop[2] = prop[0] / 5\n        prop[3] = prop[0] % 5\n\n        this.lc = prop[1]\n        this.pb = prop[2]\n        this.lp = prop[3]\n\n        this.dictSizeInProperties = 0\n        for (var i: u8 = 0; i < 4; i++) {\n            this.dictSizeInProperties |= properties[i + 1] << (8 * i)\n        }\n\n        this.dictSize = this.dictSizeInProperties\n\n        if (this.dictSize < LZMA.LZMA_DIC_MIN) {\n            this.dictSize = LZMA.LZMA_DIC_MIN\n        }\n    }\n    private updateState_Literal(state: u8): u8 {\n        if (state < 4) return 0\n        else if (state < 10) return state - 3\n        else return state - 6\n    }\n    private updateState_ShortRep(state: u8): u8 {\n        return state < 7 ? 9 : 11\n    }\n    private updateState_Rep(state: u8): u8 {\n        return state < 7 ? 8 : 11\n    }\n    private updateState_Match(state: u8): u8 {\n        return state < 7 ? 7 : 10\n    }\n\n    public decode(unpackSizeDefined: boolean, unpackSize: i32): i32 {\n        //UInt64\n        this.init()\n        this.rangeDec.init()\n\n        if (unpackSizeDefined) {\n            this.outWindow.outStream = new Uint8Array(unpackSize)\n        }\n\n        var rep0:u32 = 0,\n            rep1:u32 = 0,\n            rep2:u32 = 0,\n            rep3:u32 = 0 //UInt32\n        var state:u8 = 0 //unsigned byte\n\n        for (;;) {\n            if (unpackSizeDefined && unpackSize == 0 && !this.markerIsMandatory) {\n                if (this.rangeDec.isFinishedOK()) {\n                    return LZMA.LZMA_RES_FINISHED_WITHOUT_MARKER\n                }\n            }\n\n            var posState = this.outWindow.totalPos & ((1 << this.pb) - 1)\n\n            if (this.rangeDec.decodeBit(this.isMatch, (state << LZMA.kNumPosBitsMax) + posState) == 0) {\n                if (unpackSizeDefined && unpackSize == 0) {\n                    return LZMA.LZMA_RES_ERROR\n                }\n                this.decodeLiteral(state, rep0)\n                state = this.updateState_Literal(state)\n                unpackSize--\n                continue\n            }\n\n            var len: i32\n\n            if (this.rangeDec.decodeBit(this.isRep, state) != 0) {\n                if (unpackSizeDefined && unpackSize == 0) {\n                    return LZMA.LZMA_RES_ERROR\n                }\n                if (this.outWindow.isEmpty()) {\n                    return LZMA.LZMA_RES_ERROR\n                }\n                if (this.rangeDec.decodeBit(this.isRepG0, state) == 0) {\n                    if (this.rangeDec.decodeBit(this.isRep0Long, (state << LZMA.kNumPosBitsMax) + posState) == 0) {\n                        state = this.updateState_ShortRep(state)\n                        this.outWindow.putByte(this.outWindow.getByte(rep0 + 1))\n                        unpackSize--\n                        continue\n                    }\n                } else {\n                    var dist: i32\n                    if (this.rangeDec.decodeBit(this.isRepG1, state) == 0) {\n                        dist = rep1\n                    } else {\n                        if (this.rangeDec.decodeBit(this.isRepG2, state) == 0) {\n                            dist = rep2\n                        } else {\n                            dist = rep3\n                            rep3 = rep2\n                        }\n                        rep2 = rep1\n                    }\n                    rep1 = rep0\n                    rep0 = dist\n                }\n                len = this.repLenDecoder.decode(this.rangeDec, posState)\n                state = this.updateState_Rep(state)\n            } else {\n                rep3 = rep2\n                rep2 = rep1\n                rep1 = rep0\n                len = this.lenDecoder.decode(this.rangeDec, posState)\n                state = this.updateState_Match(state)\n                rep0 = this.decodeDistance(len)\n                if (rep0 == 0xffffffff) {\n                    return this.rangeDec.isFinishedOK() ? LZMA.LZMA_RES_FINISHED_WITH_MARKER : LZMA.LZMA_RES_ERROR\n                }\n\n                if (unpackSizeDefined && unpackSize == 0) {\n                    return LZMA.LZMA_RES_ERROR\n                }\n                if (rep0 >= this.dictSize || !this.outWindow.checkDistance(rep0)) {\n                    return LZMA.LZMA_RES_ERROR\n                }\n            }\n            len += LZMA.kMatchMinLen\n            var isError: boolean = false\n            if (unpackSizeDefined && unpackSize < len) {\n                len = unpackSize\n                isError = true\n            }\n            this.outWindow.copyMatch(rep0 + 1, len)\n            unpackSize -= len\n            if (isError) {\n                return LZMA.LZMA_RES_ERROR\n            }\n        }\n        return 0;\n    }\n}\n","import {\n  AL_MASK,\n  MAX_SIZE_32\n } from \"./allocator\";\n\n/** Size of an ArrayBuffer header. */\n@inline export const HEADER_SIZE: usize = (offsetof<ArrayBuffer>() + AL_MASK) & ~AL_MASK;\n/** Maximum byte length of an ArrayBuffer. */\n@inline export const MAX_BLENGTH: i32 = <i32>MAX_SIZE_32 - HEADER_SIZE;\n\nfunction computeSize(byteLength: i32): usize {\n  // round up to power of 2, with HEADER_SIZE=8:\n  // 0            -> 2^3  = 8\n  // 1..8         -> 2^4  = 16\n  // 9..24        -> 2^5  = 32\n  // ...\n  // MAX_LENGTH   -> 2^30 = 0x40000000 (MAX_SIZE_32)\n  return <usize>1 << <usize>(<u32>32 - clz<u32>(byteLength + HEADER_SIZE - 1));\n}\n\n// Low-level utility\n\nfunction __gc(ref: usize): void {}\n\nexport function allocateUnsafe(byteLength: i32): ArrayBuffer {\n  assert(<u32>byteLength <= <u32>MAX_BLENGTH);\n  var buffer: usize;\n  if (isManaged<ArrayBuffer>()) {\n    buffer = __gc_allocate(computeSize(byteLength), __gc); // tslint:disable-line\n  } else {\n    buffer = memory.allocate(computeSize(byteLength));\n  }\n  store<i32>(buffer, byteLength, offsetof<ArrayBuffer>(\"byteLength\"));\n  return changetype<ArrayBuffer>(buffer);\n}\n\nexport function reallocateUnsafe(buffer: ArrayBuffer, newByteLength: i32): ArrayBuffer {\n  var oldByteLength = buffer.byteLength;\n  if (newByteLength > oldByteLength) {\n    assert(newByteLength <= MAX_BLENGTH);\n    if (newByteLength <= <i32>(computeSize(oldByteLength) - HEADER_SIZE)) { // fast path: zero out additional space\n      store<i32>(changetype<usize>(buffer), newByteLength, offsetof<ArrayBuffer>(\"byteLength\"));\n    } else { // slow path: copy to new buffer\n      let newBuffer = allocateUnsafe(newByteLength);\n      memory.copy(\n        changetype<usize>(newBuffer) + HEADER_SIZE,\n        changetype<usize>(buffer) + HEADER_SIZE,\n        <usize>oldByteLength\n      );\n      if (!isManaged<ArrayBuffer>()) {\n        memory.free(changetype<usize>(buffer));\n      }\n      buffer = newBuffer;\n    }\n    memory.fill(\n      changetype<usize>(buffer) + HEADER_SIZE + <usize>oldByteLength,\n      0,\n      <usize>(newByteLength - oldByteLength)\n    );\n  } else if (newByteLength < oldByteLength) { // fast path: override size\n    // TBD: worth to copy and release if size is significantly less than before?\n    assert(newByteLength >= 0);\n    store<i32>(changetype<usize>(buffer), newByteLength, offsetof<ArrayBuffer>(\"byteLength\"));\n  }\n  return buffer;\n}\n\n// The helpers below use two different types in order to emit loads and stores that load respectively\n// store one type to/from memory while returning/taking the desired output/input type. This allows to\n// emit instructions like\n//\n// * `i32.load8` ^= `<i32>load<i8>(...)` that reads an i8 but returns an i32, or\n// * `i64.load32_s` ^= `<i64>load<i32>(...)`) that reads a 32-bit as a 64-bit integer\n//\n// without having to emit an additional instruction for conversion purposes. The second parameter\n// can be omitted for references and other loads and stores that simply return the exact type.\n\n@inline export function LOAD<T,TOut = T>(buffer: ArrayBuffer, index: i32, byteOffset: i32 = 0): TOut {\n  return <TOut>load<T>(changetype<usize>(buffer) + (<usize>index << alignof<T>()) + <usize>byteOffset, HEADER_SIZE);\n}\n\n@inline export function STORE<T,TIn = T>(buffer: ArrayBuffer, index: i32, value: TIn, byteOffset: i32 = 0): void {\n  store<T>(changetype<usize>(buffer) + (<usize>index << alignof<T>()) + <usize>byteOffset, value, HEADER_SIZE);\n}\n","import { MAX_SIZE_32 } from \"./allocator\";\nimport { String } from \"../string\";\n\n/** Size of a String header. */\n@inline export const HEADER_SIZE = (offsetof<String>() + 1) & ~1; // 2 byte aligned\n/** Maximum length of a String. */\n@inline export const MAX_LENGTH = (<i32>MAX_SIZE_32 - HEADER_SIZE) >>> 1;\n\n// Low-level utility\n\nfunction __gc(ref: usize): void {}\n\nexport function allocateUnsafe(length: i32): String {\n  assert(length > 0 && length <= MAX_LENGTH);\n  var buffer: usize;\n  if (isManaged<String>()) {\n    buffer = __gc_allocate(HEADER_SIZE + (<usize>length << 1), __gc);  // tslint:disable-line\n  } else {\n    buffer = memory.allocate(HEADER_SIZE + (<usize>length << 1));\n  }\n  store<i32>(buffer, length);\n  return changetype<String>(buffer);\n}\n\n@inline\nexport function freeUnsafe(buffer: String): void {\n  if (!isManaged<String>()) {\n    assert(buffer);\n    memory.free(changetype<usize>(buffer));\n  }\n}\n\nexport function copyUnsafe(dest: String, destOffset: usize, src: String, srcOffset: usize, len: usize): void {\n  memory.copy(\n    changetype<usize>(dest) + (destOffset << 1) + HEADER_SIZE,\n    changetype<usize>(src)  + (srcOffset  << 1) + HEADER_SIZE,\n    len << 1\n  );\n}\n\nexport function compareUnsafe(str1: String, offset1: usize, str2: String, offset2: usize, len: usize): i32 {\n  var cmp: i32 = 0;\n  var ptr1 = changetype<usize>(str1) + (offset1 << 1);\n  var ptr2 = changetype<usize>(str2) + (offset2 << 1);\n  while (len && !(cmp = <i32>load<u16>(ptr1, HEADER_SIZE) - <i32>load<u16>(ptr2, HEADER_SIZE))) {\n    --len, ptr1 += 2, ptr2 += 2;\n  }\n  return cmp;\n}\n\nexport function repeatUnsafe(dest: String, destOffset: usize, src: String, count: i32): void {\n  var length = src.length;\n  if (ASC_SHRINK_LEVEL > 1) {\n    let strLen = length << 1;\n    let to   = changetype<usize>(dest) + HEADER_SIZE + (destOffset << 1);\n    let from = changetype<usize>(src)  + HEADER_SIZE;\n    for (let i = 0, len = strLen * count; i < len; i += strLen) {\n      memory.copy(to + i, from, strLen);\n    }\n  } else {\n    switch (length) {\n      case 0: break;\n      case 1: {\n        let cc =  load<u16>(changetype<usize>(src), HEADER_SIZE);\n        let out = changetype<usize>(dest) + (destOffset << 1);\n        for (let i = 0; i < count; ++i) {\n          store<u16>(out + (i << 1), cc, HEADER_SIZE);\n        }\n        break;\n      }\n      case 2: {\n        let cc  = load<u32>(changetype<usize>(src), HEADER_SIZE);\n        let out = changetype<usize>(dest) + (destOffset << 1);\n        for (let i = 0; i < count; ++i) {\n          store<u32>(out + (i << 2), cc, HEADER_SIZE);\n        }\n        break;\n      }\n      case 3: {\n        let cc1 = load<u32>(changetype<usize>(src), HEADER_SIZE + 0);\n        let cc2 = load<u16>(changetype<usize>(src), HEADER_SIZE + 4);\n        let out = changetype<usize>(dest) + (destOffset << 1);\n        for (let i = 0; i < count; ++i) {\n          store<u32>(out + (i << 2), cc1, HEADER_SIZE + 0);\n          store<u16>(out + (i << 1), cc2, HEADER_SIZE + 4);\n        }\n        break;\n      }\n      case 4: {\n        let cc = load<u64>(changetype<usize>(src), HEADER_SIZE);\n        let out = changetype<usize>(dest) + (destOffset << 1);\n        for (let i = 0; i < count; ++i) {\n          store<u64>(out + (i << 3), cc, HEADER_SIZE);\n        }\n        break;\n      }\n      default: {\n        let strLen = length << 1;\n        let to   = changetype<usize>(dest) + HEADER_SIZE + (destOffset << 1);\n        let from = changetype<usize>(src)  + HEADER_SIZE;\n        for (let i = 0, len = strLen * count; i < len; i += strLen) {\n          memory.copy(to + i, from, strLen);\n        }\n        break;\n      }\n    }\n  }\n}\n\n// Helpers\n\n@inline export const enum CharCode {\n  PLUS = 0x2B,\n  MINUS = 0x2D,\n  DOT = 0x2E,\n  _0 = 0x30,\n  _1 = 0x31,\n  _2 = 0x32,\n  _3 = 0x33,\n  _4 = 0x34,\n  _5 = 0x35,\n  _6 = 0x36,\n  _7 = 0x37,\n  _8 = 0x38,\n  _9 = 0x39,\n  A = 0x41,\n  B = 0x42,\n  E = 0x45,\n  N = 0x4E,\n  O = 0x4F,\n  X = 0x58,\n  Z = 0x5a,\n  a = 0x61,\n  b = 0x62,\n  e = 0x65,\n  n = 0x6E,\n  o = 0x6F,\n  x = 0x78,\n  z = 0x7A\n}\n\nexport function isWhiteSpaceOrLineTerminator(c: u16): bool {\n  switch (c) {\n    case 9:    // <TAB>\n    case 10:   // <LF>\n    case 13:   // <CR>\n    case 11:   // <VT>\n    case 12:   // <FF>\n    case 32:   // <SP>\n    case 160:  // <NBSP>\n    case 8232: // <LS>\n    case 8233: // <PS>\n    case 65279: return true; // <ZWNBSP>\n    default: return false;\n  }\n}\n\n/** Parses a string to an integer (usually), using the specified radix. */\nexport function parse<T>(str: String, radix: i32 = 0): T {\n  var len: i32 = str.length;\n  if (!len) return <T>NaN;\n\n  var ptr = changetype<usize>(str) /* + HEAD -> offset */;\n  var code = <i32>load<u16>(ptr, HEADER_SIZE);\n\n  // determine sign\n  var sign: T;\n  if (code == CharCode.MINUS) {\n    if (!--len) return <T>NaN;\n    code = <i32>load<u16>(ptr += 2, HEADER_SIZE);\n    sign = -1;\n  } else if (code == CharCode.PLUS) {\n    if (!--len) return <T>NaN;\n    code = <i32>load<u16>(ptr += 2, HEADER_SIZE);\n    sign = 1;\n  } else {\n    sign = 1;\n  }\n\n  // determine radix\n  if (!radix) {\n    if (code == CharCode._0 && len > 2) {\n      switch (<i32>load<u16>(ptr + 2, HEADER_SIZE)) {\n        case CharCode.B:\n        case CharCode.b: {\n          ptr += 4; len -= 2;\n          radix = 2;\n          break;\n        }\n        case CharCode.O:\n        case CharCode.o: {\n          ptr += 4; len -= 2;\n          radix = 8;\n          break;\n        }\n        case CharCode.X:\n        case CharCode.x: {\n          ptr += 4; len -= 2;\n          radix = 16;\n          break;\n        }\n        default: radix = 10;\n      }\n    } else radix = 10;\n  } else if (radix < 2 || radix > 36) {\n    return <T>NaN;\n  }\n\n  // calculate value\n  var num: T = 0;\n  while (len--) {\n    code = <i32>load<u16>(ptr, HEADER_SIZE);\n    if (code >= CharCode._0 && code <= CharCode._9) {\n      code -= CharCode._0;\n    } else if (code >= CharCode.A && code <= CharCode.Z) {\n      code -= CharCode.A - 10;\n    } else if (code >= CharCode.a && code <= CharCode.z) {\n      code -= CharCode.a - 10;\n    } else break;\n    if (code >= radix) break;\n    num = (num * radix) + code;\n    ptr += 2;\n  }\n  return sign * num;\n}\n","import {\n  CharCode,\n  allocateUnsafe as allocateUnsafeString,\n  freeUnsafe as freeUnsafeString,\n  HEADER_SIZE as STRING_HEADER_SIZE\n} from \"./string\";\n\nimport {\n  LOAD\n} from \"./arraybuffer\";\n\n@inline export const MAX_DOUBLE_LENGTH = 28;\n\n@lazy @inline const POWERS10: u32[] = [\n  1,\n  10,\n  100,\n  1000,\n  10000,\n  100000,\n  1000000,\n  10000000,\n  100000000,\n  1000000000\n];\n\n/*\n  Lookup table for pairwise char codes in range [0-99]\n\n  \"00\", \"01\", \"02\", \"03\", \"04\", \"05\", \"06\", \"07\", \"08\", \"09\",\n  \"10\", \"11\", \"12\", \"13\", \"14\", \"15\", \"16\", \"17\", \"18\", \"19\",\n  \"20\", \"21\", \"22\", \"23\", \"24\", \"25\", \"26\", \"27\", \"28\", \"29\",\n  \"30\", \"31\", \"32\", \"33\", \"34\", \"35\", \"36\", \"37\", \"38\", \"39\",\n  \"40\", \"41\", \"42\", \"43\", \"44\", \"45\", \"46\", \"47\", \"48\", \"49\",\n  \"50\", \"51\", \"52\", \"53\", \"54\", \"55\", \"56\", \"57\", \"58\", \"59\",\n  \"60\", \"61\", \"62\", \"63\", \"64\", \"65\", \"66\", \"67\", \"68\", \"69\",\n  \"70\", \"71\", \"72\", \"73\", \"74\", \"75\", \"76\", \"77\", \"78\", \"79\",\n  \"80\", \"81\", \"82\", \"83\", \"84\", \"85\", \"86\", \"87\", \"88\", \"89\",\n  \"90\", \"91\", \"92\", \"93\", \"94\", \"95\", \"96\", \"97\", \"98\", \"99\"\n*/\n@lazy @inline const DIGITS: u32[] = [\n  0x00300030, 0x00310030, 0x00320030, 0x00330030, 0x00340030,\n  0x00350030, 0x00360030, 0x00370030, 0x00380030, 0x00390030,\n  0x00300031, 0x00310031, 0x00320031, 0x00330031, 0x00340031,\n  0x00350031, 0x00360031, 0x00370031, 0x00380031, 0x00390031,\n  0x00300032, 0x00310032, 0x00320032, 0x00330032, 0x00340032,\n  0x00350032, 0x00360032, 0x00370032, 0x00380032, 0x00390032,\n  0x00300033, 0x00310033, 0x00320033, 0x00330033, 0x00340033,\n  0x00350033, 0x00360033, 0x00370033, 0x00380033, 0x00390033,\n  0x00300034, 0x00310034, 0x00320034, 0x00330034, 0x00340034,\n  0x00350034, 0x00360034, 0x00370034, 0x00380034, 0x00390034,\n  0x00300035, 0x00310035, 0x00320035, 0x00330035, 0x00340035,\n  0x00350035, 0x00360035, 0x00370035, 0x00380035, 0x00390035,\n  0x00300036, 0x00310036, 0x00320036, 0x00330036, 0x00340036,\n  0x00350036, 0x00360036, 0x00370036, 0x00380036, 0x00390036,\n  0x00300037, 0x00310037, 0x00320037, 0x00330037, 0x00340037,\n  0x00350037, 0x00360037, 0x00370037, 0x00380037, 0x00390037,\n  0x00300038, 0x00310038, 0x00320038, 0x00330038, 0x00340038,\n  0x00350038, 0x00360038, 0x00370038, 0x00380038, 0x00390038,\n  0x00300039, 0x00310039, 0x00320039, 0x00330039, 0x00340039,\n  0x00350039, 0x00360039, 0x00370039, 0x00380039, 0x00390039\n];\n\n@lazy @inline const EXP_POWERS: i16[] = [\n  -1220, -1193, -1166, -1140, -1113, -1087, -1060, -1034, -1007,  -980,\n   -954,  -927,  -901,  -874,  -847,  -821,  -794,  -768,  -741,  -715,\n   -688,  -661,  -635,  -608,  -582,  -555,  -529,  -502,  -475,  -449,\n   -422,  -396,  -369,  -343,  -316,  -289,  -263,  -236,  -210,  -183,\n   -157,  -130,  -103,   -77,   -50,   -24,     3,    30,    56,    83,\n    109,   136,   162,   189,   216,   242,   269,   295,   322,   348,\n    375,   402,   428,   455,   481,   508,   534,   561,   588,   614,\n    641,   667,   694,   720,   747,   774,   800,   827,   853,   880,\n    907,   933,   960,   986,  1013,  1039,  1066\n];\n\n// 1e-348, 1e-340, ..., 1e340\n@lazy @inline const FRC_POWERS: u64[] = [\n  0xFA8FD5A0081C0288, 0xBAAEE17FA23EBF76, 0x8B16FB203055AC76, 0xCF42894A5DCE35EA,\n  0x9A6BB0AA55653B2D, 0xE61ACF033D1A45DF, 0xAB70FE17C79AC6CA, 0xFF77B1FCBEBCDC4F,\n  0xBE5691EF416BD60C, 0x8DD01FAD907FFC3C, 0xD3515C2831559A83, 0x9D71AC8FADA6C9B5,\n  0xEA9C227723EE8BCB, 0xAECC49914078536D, 0x823C12795DB6CE57, 0xC21094364DFB5637,\n  0x9096EA6F3848984F, 0xD77485CB25823AC7, 0xA086CFCD97BF97F4, 0xEF340A98172AACE5,\n  0xB23867FB2A35B28E, 0x84C8D4DFD2C63F3B, 0xC5DD44271AD3CDBA, 0x936B9FCEBB25C996,\n  0xDBAC6C247D62A584, 0xA3AB66580D5FDAF6, 0xF3E2F893DEC3F126, 0xB5B5ADA8AAFF80B8,\n  0x87625F056C7C4A8B, 0xC9BCFF6034C13053, 0x964E858C91BA2655, 0xDFF9772470297EBD,\n  0xA6DFBD9FB8E5B88F, 0xF8A95FCF88747D94, 0xB94470938FA89BCF, 0x8A08F0F8BF0F156B,\n  0xCDB02555653131B6, 0x993FE2C6D07B7FAC, 0xE45C10C42A2B3B06, 0xAA242499697392D3,\n  0xFD87B5F28300CA0E, 0xBCE5086492111AEB, 0x8CBCCC096F5088CC, 0xD1B71758E219652C,\n  0x9C40000000000000, 0xE8D4A51000000000, 0xAD78EBC5AC620000, 0x813F3978F8940984,\n  0xC097CE7BC90715B3, 0x8F7E32CE7BEA5C70, 0xD5D238A4ABE98068, 0x9F4F2726179A2245,\n  0xED63A231D4C4FB27, 0xB0DE65388CC8ADA8, 0x83C7088E1AAB65DB, 0xC45D1DF942711D9A,\n  0x924D692CA61BE758, 0xDA01EE641A708DEA, 0xA26DA3999AEF774A, 0xF209787BB47D6B85,\n  0xB454E4A179DD1877, 0x865B86925B9BC5C2, 0xC83553C5C8965D3D, 0x952AB45CFA97A0B3,\n  0xDE469FBD99A05FE3, 0xA59BC234DB398C25, 0xF6C69A72A3989F5C, 0xB7DCBF5354E9BECE,\n  0x88FCF317F22241E2, 0xCC20CE9BD35C78A5, 0x98165AF37B2153DF, 0xE2A0B5DC971F303A,\n  0xA8D9D1535CE3B396, 0xFB9B7CD9A4A7443C, 0xBB764C4CA7A44410, 0x8BAB8EEFB6409C1A,\n  0xD01FEF10A657842C, 0x9B10A4E5E9913129, 0xE7109BFBA19C0C9D, 0xAC2820D9623BF429,\n  0x80444B5E7AA7CF85, 0xBF21E44003ACDD2D, 0x8E679C2F5E44FF8F, 0xD433179D9C8CB841,\n  0x9E19DB92B4E31BA9, 0xEB96BF6EBADF77D9, 0xAF87023B9BF0EE6B\n];\n\n// Count number of decimals for u32 values\n// In our case input value always non-zero so we can simplify some parts\nexport function decimalCount32(value: u32): u32 {\n  if (ASC_SHRINK_LEVEL >= 1) {\n    let l: u32 = 32 - clz<u32>(value); // log2\n    let t = l * 1233 >>> 12; // log10\n\n    let lutbuf = <ArrayBuffer>POWERS10.buffer_;\n    let power  = LOAD<u32>(lutbuf, t);\n    t -= <u32>(value < power);\n    return t + 1;\n  } else {\n    if (value < 100000) {\n      if (value < 100) {\n        return select<u32>(1, 2, value < 10);\n      } else {\n        let m = select<u32>(4, 5, value < 10000);\n        return select<u32>(3, m, value < 1000);\n      }\n    } else {\n      if (value < 10000000) {\n        return select<u32>(6, 7, value < 1000000);\n      } else {\n        let m = select<u32>(9, 10, value < 1000000000);\n        return select<u32>(8, m, value < 100000000);\n      }\n    }\n  }\n}\n\n// Count number of decimals for u64 values\n// In our case input value always greater than 2^32-1 so we can skip some parts\nexport function decimalCount64(value: u64): u32 {\n  if (ASC_SHRINK_LEVEL >= 1) {\n    let l: u32 = 64 - <u32>clz<u64>(value); // log2\n    let t = l * 1233 >>> 12; // log10\n\n    let lutbuf = <ArrayBuffer>POWERS10.buffer_;\n    let power  = LOAD<u32,u64>(lutbuf, t - 10);\n    t -= <u32>(value < 10000000000 * power);\n    return t + 1;\n  } else {\n    if (value < 1000000000000000) {\n      if (value < 1000000000000) {\n        return select<u32>(11, 12, value < 100000000000);\n      } else {\n        let m = select<u32>(14, 15, value < 100000000000000);\n        return select<u32>(13, m, value < 10000000000000);\n      }\n    } else {\n      if (value < 100000000000000000) {\n        return select<u32>(16, 17, value < 10000000000000000);\n      } else {\n        let m = select<u32>(19, 20, value < 10000000000000000000);\n        return select<u32>(18, m, value < 1000000000000000000);\n      }\n    }\n  }\n}\n\nfunction utoa32_lut(buffer: usize, num: u32, offset: usize): void {\n  var lutbuf = <ArrayBuffer>DIGITS.buffer_;\n\n  while (num >= 10000) {\n    // in most VMs i32/u32 div and modulo by constant can be shared and simplificate\n    let t = num / 10000;\n    let r = num % 10000;\n    num = t;\n\n    let d1 = r / 100;\n    let d2 = r % 100;\n\n    let digits1 = LOAD<u32,u64>(lutbuf, d1);\n    let digits2 = LOAD<u32,u64>(lutbuf, d2);\n\n    offset -= 4;\n    store<u64>(buffer + (offset << 1), digits1 | (digits2 << 32), STRING_HEADER_SIZE);\n  }\n\n  if (num >= 100) {\n    let t  = num / 100;\n    let d1 = num % 100;\n    num = t;\n    offset -= 2;\n    let digits = LOAD<u32>(lutbuf, d1);\n    store<u32>(buffer + (offset << 1), digits, STRING_HEADER_SIZE);\n  }\n\n  if (num >= 10) {\n    offset -= 2;\n    let digits = LOAD<u32>(lutbuf, num);\n    store<u32>(buffer + (offset << 1), digits, STRING_HEADER_SIZE);\n  } else {\n    offset -= 1;\n    let digit = CharCode._0 + num;\n    store<u16>(buffer + (offset << 1), digit, STRING_HEADER_SIZE);\n  }\n}\n\nfunction utoa64_lut(buffer: usize, num: u64, offset: usize): void {\n  var lutbuf = <ArrayBuffer>DIGITS.buffer_;\n\n  while (num >= 100000000) {\n    let t = num / 100000000;\n    let r = <usize>(num - t * 100000000);\n    num = t;\n\n    let b = r / 10000;\n    let c = r % 10000;\n\n    let b1 = b / 100;\n    let b2 = b % 100;\n    let c1 = c / 100;\n    let c2 = c % 100;\n\n    let digits1 = LOAD<u32,u64>(lutbuf, c1);\n    let digits2 = LOAD<u32,u64>(lutbuf, c2);\n\n    offset -= 4;\n    store<u64>(buffer + (offset << 1), digits1 | (digits2 << 32), STRING_HEADER_SIZE);\n\n    digits1 = LOAD<u32,u64>(lutbuf, b1);\n    digits2 = LOAD<u32,u64>(lutbuf, b2);\n\n    offset -= 4;\n    store<u64>(buffer + (offset << 1), digits1 | (digits2 << 32), STRING_HEADER_SIZE);\n  }\n\n  utoa32_lut(buffer, <u32>num, offset);\n}\n\nfunction utoa_simple<T>(buffer: usize, num: T, offset: usize): void {\n  do {\n    let t = num / 10;\n    let r = <u32>(num % 10);\n    num = t;\n    offset -= 1;\n    store<u16>(buffer + (offset << 1), CharCode._0 + r, STRING_HEADER_SIZE);\n  } while (num);\n}\n\n@inline\nexport function utoa32_core(buffer: usize, num: u32, offset: u32): void {\n  if (ASC_SHRINK_LEVEL >= 1) {\n    utoa_simple(buffer, num, offset);\n  } else {\n    utoa32_lut(buffer, num, offset);\n  }\n}\n\n@inline\nexport function utoa64_core(buffer: usize, num: u64, offset: u32): void {\n  if (ASC_SHRINK_LEVEL >= 1) {\n    utoa_simple(buffer, num, offset);\n  } else {\n    utoa64_lut(buffer, num, offset);\n  }\n}\n\nexport function utoa32(value: u32): String {\n  if (!value) return \"0\";\n\n  var decimals = decimalCount32(value);\n  var buffer   = allocateUnsafeString(decimals);\n\n  utoa32_core(changetype<usize>(buffer), value, decimals);\n  return buffer;\n}\n\nexport function itoa32(value: i32): String {\n  if (!value) return \"0\";\n\n  var sign = value < 0;\n  if (sign) value = -value;\n\n  var decimals = decimalCount32(value) + <u32>sign;\n  var buffer   = allocateUnsafeString(decimals);\n\n  utoa32_core(changetype<usize>(buffer), value, decimals);\n  if (sign) store<u16>(changetype<usize>(buffer), CharCode.MINUS, STRING_HEADER_SIZE);\n\n  return buffer;\n}\n\nexport function utoa64(value: u64): String {\n  if (!value) return \"0\";\n\n  var buffer: String;\n  if (value <= u32.MAX_VALUE) {\n    let val32    = <u32>value;\n    let decimals = decimalCount32(val32);\n    buffer = allocateUnsafeString(decimals);\n    utoa32_core(changetype<usize>(buffer), val32, decimals);\n  } else {\n    let decimals = decimalCount64(value);\n    buffer = allocateUnsafeString(decimals);\n    utoa64_core(changetype<usize>(buffer), value, decimals);\n  }\n  return buffer;\n}\n\nexport function itoa64(value: i64): String {\n  if (!value) return \"0\";\n\n  var sign = value < 0;\n  if (sign) value = -value;\n\n  var buffer: String;\n  if (<u64>value <= <u64>u32.MAX_VALUE) {\n    let val32    = <u32>value;\n    let decimals = decimalCount32(val32) + <u32>sign;\n    buffer = allocateUnsafeString(decimals);\n    utoa32_core(changetype<usize>(buffer), val32, decimals);\n  } else {\n    let decimals = decimalCount64(value) + <u32>sign;\n    buffer = allocateUnsafeString(decimals);\n    utoa64_core(changetype<usize>(buffer), value, decimals);\n  }\n  if (sign) store<u16>(changetype<usize>(buffer), CharCode.MINUS, STRING_HEADER_SIZE);\n\n  return buffer;\n}\n\nexport function itoa<T>(value: T): String {\n  if (!isInteger<T>()) {\n    assert(false); // unexpecteble non-integer generic type\n  } else {\n    if (isSigned<T>()) {\n      if (sizeof<T>() <= 4) {\n        return itoa32(<i32>value);\n      } else {\n        return itoa64(<i64>value);\n      }\n    } else {\n      if (sizeof<T>() <= 4) {\n        return utoa32(<u32>value);\n      } else {\n        return utoa64(<u64>value);\n      }\n    }\n  }\n}\n\n@lazy var _K: i32 = 0;\n// @lazy var _frc: u64 = 0;\n@lazy var _exp: i32 = 0;\n@lazy var _frc_minus: u64 = 0;\n@lazy var _frc_plus:  u64 = 0;\n@lazy var _frc_pow: u64 = 0;\n@lazy var _exp_pow: i32 = 0;\n\n@inline\nfunction umul64f(u: u64, v: u64): u64 {\n  var u0 = u & 0xFFFFFFFF;\n  var v0 = v & 0xFFFFFFFF;\n\n  var u1 = u >> 32;\n  var v1 = v >> 32;\n\n  var l = u0 * v0;\n  var t = u1 * v0 + (l >> 32);\n  var w = u0 * v1 + (t & 0xFFFFFFFF);\n\n  w += 0x7FFFFFFF; // rounding\n\n  t >>= 32;\n  w >>= 32;\n\n  return u1 * v1 + t + w;\n}\n\n@inline\nfunction umul64e(e1: i32, e2: i32): i32 {\n  return e1 + e2 + 64; // where 64 is significand size\n}\n\n@inline\nfunction normalizedBoundaries(f: u64, e: i32): void {\n  var frc = (f << 1) + 1;\n  var exp = e - 1;\n  var off = <i32>clz<u64>(frc);\n  frc <<= off;\n  exp  -= off;\n\n  var m = 1 + <i32>(f == 0x0010000000000000);\n\n  _frc_plus  = frc;\n  _frc_minus = ((f << m) - 1) << e - m - exp;\n  _exp = exp;\n}\n\n@inline\nfunction grisuRound(buffer: usize, len: i32, delta: u64, rest: u64, ten_kappa: u64, wp_w: u64): void {\n  var lastp = buffer + ((len - 1) << 1);\n  var digit = load<u16>(lastp, STRING_HEADER_SIZE);\n  while (\n    rest < wp_w &&\n    delta - rest >= ten_kappa && (\n      rest + ten_kappa < wp_w ||\n      wp_w - rest > rest + ten_kappa - wp_w\n    )\n  ) {\n    --digit;\n    rest += ten_kappa;\n  }\n  store<u16>(lastp, digit, STRING_HEADER_SIZE);\n}\n\n@inline\nfunction getCachedPower(minExp: i32): void {\n  const c = reinterpret<f64>(0x3FD34413509F79FE); // 1 / lg(10) = 0.30102999566398114\n  var dk = (-61 - minExp) * c + 347;\t            // dk must be positive, so can do ceiling in positive\n  var k = <i32>dk;\n      k += <i32>(k != dk); // conversion with ceil\n\n  var index = (k >> 3) + 1;\n  _K = 348 - (index << 3);\t// decimal exponent no need lookup table\n  var frcPowers = <ArrayBuffer>FRC_POWERS.buffer_;\n  var expPowers = <ArrayBuffer>EXP_POWERS.buffer_;\n  _frc_pow = LOAD<u64>(frcPowers, index);\n  _exp_pow = LOAD<i16,i32>(expPowers, index);\n}\n\n@inline\nfunction grisu2(value: f64, buffer: usize, sign: i32): i32 {\n\n  // frexp routine\n  var uv  = reinterpret<u64>(value);\n  var exp = <i32>((uv & 0x7FF0000000000000) >>> 52);\n  var sid = uv & 0x000FFFFFFFFFFFFF;\n  var frc = (<u64>(exp != 0) << 52) + sid;\n      exp = select<i32>(exp, 1, exp != 0) - (0x3FF + 52);\n\n  normalizedBoundaries(frc, exp);\n  getCachedPower(_exp);\n\n  // normalize\n  var off = <i32>clz<u64>(frc);\n  frc <<= off;\n  exp  -= off;\n\n  var frc_pow = _frc_pow;\n  var exp_pow = _exp_pow;\n\n  var w_frc = umul64f(frc, frc_pow);\n  var w_exp = umul64e(exp, exp_pow);\n\n  var wp_frc = umul64f(_frc_plus, frc_pow) - 1;\n  var wp_exp = umul64e(_exp,      exp_pow);\n\n  var wm_frc = umul64f(_frc_minus, frc_pow) + 1;\n  var delta  = wp_frc - wm_frc;\n\n  return genDigits(buffer, w_frc, w_exp, wp_frc, wp_exp, delta, sign);\n}\n\nfunction genDigits(buffer: usize, w_frc: u64, w_exp: i32, mp_frc: u64, mp_exp: i32, delta: u64, sign: i32): i32 {\n  var one_exp = -mp_exp;\n  var one_frc = (<u64>1) << one_exp;\n  var mask    = one_frc - 1;\n\n  var wp_w_frc = mp_frc - w_frc;\n  var wp_w_exp = mp_exp;\n\n  var p1 = <u32>(mp_frc >> one_exp);\n  var p2 = mp_frc & mask;\n\n  var kappa = <i32>decimalCount32(p1);\n  var len = sign;\n\n  var powers10 = <ArrayBuffer>POWERS10.buffer_;\n\n  while (kappa > 0) {\n    let d: u32;\n    switch (kappa) {\n      case 10: { d = p1 / 1000000000; p1 %= 1000000000; break; }\n      case  9: { d = p1 /  100000000; p1 %=  100000000; break; }\n      case  8: { d = p1 /   10000000; p1 %=   10000000; break; }\n      case  7: { d = p1 /    1000000; p1 %=    1000000; break; }\n      case  6: { d = p1 /     100000; p1 %=     100000; break; }\n      case  5: { d = p1 /      10000; p1 %=      10000; break; }\n      case  4: { d = p1 /       1000; p1 %=       1000; break; }\n      case  3: { d = p1 /        100; p1 %=        100; break; }\n      case  2: { d = p1 /         10; p1 %=         10; break; }\n      case  1: { d = p1;              p1 =           0; break; }\n      default: { d = 0; break; }\n    }\n\n    if (d | len) store<u16>(buffer + (len++ << 1), CharCode._0 + <u16>d, STRING_HEADER_SIZE);\n\n    --kappa;\n    let tmp = ((<u64>p1) << one_exp) + p2;\n    if (tmp <= delta) {\n      _K += kappa;\n      grisuRound(buffer, len, delta, tmp, LOAD<u32,u64>(powers10, kappa) << one_exp, wp_w_frc);\n      return len;\n    }\n  }\n\n  while (1) {\n    p2    *= 10;\n    delta *= 10;\n\n    let d = p2 >> one_exp;\n    if (d | len) store<u16>(buffer + (len++ << 1), CharCode._0 + <u16>d, STRING_HEADER_SIZE);\n\n    p2 &= mask;\n    --kappa;\n    if (p2 < delta) {\n      _K += kappa;\n      wp_w_frc *= LOAD<u32,u64>(powers10, -kappa);\n      grisuRound(buffer, len, delta, p2, one_frc, wp_w_frc);\n      return len;\n    }\n  }\n\n  return len;\n}\n\n@inline\nfunction genExponent(buffer: usize, k: i32): i32 {\n  var sign = k < 0;\n  if (sign) k = -k;\n  var decimals = decimalCount32(k) + 1;\n  utoa32_core(buffer, k, decimals);\n  store<u16>(buffer, <u16>select<u32>(CharCode.MINUS, CharCode.PLUS, sign), STRING_HEADER_SIZE);\n  return decimals;\n}\n\nfunction prettify(buffer: usize, length: i32, k: i32): i32 {\n  if (!k) {\n    store<u32>(buffer + (length << 1), CharCode.DOT | (CharCode._0 << 16), STRING_HEADER_SIZE);\n    return length + 2;\n  }\n\n  var kk = length + k;\n  if (length <= kk && kk <= 21) {\n    // 1234e7 -> 12340000000\n    for (let i = length; i < kk; ++i) {\n      store<u16>(buffer + (i << 1), CharCode._0, STRING_HEADER_SIZE);\n    }\n    store<u32>(buffer + (kk << 1), CharCode.DOT | (CharCode._0 << 16), STRING_HEADER_SIZE);\n    return kk + 2;\n  } else if (kk > 0 && kk <= 21) {\n    // 1234e-2 -> 12.34\n    let ptr = buffer + (kk << 1);\n    memory.copy(\n      ptr + STRING_HEADER_SIZE + 2,\n      ptr + STRING_HEADER_SIZE,\n      -k << 1\n    );\n    store<u16>(buffer + (kk << 1), CharCode.DOT, STRING_HEADER_SIZE);\n    return length + 1;\n  } else if (-6 < kk && kk <= 0) {\n    // 1234e-6 -> 0.001234\n    let offset = 2 - kk;\n    memory.copy(\n      buffer + STRING_HEADER_SIZE + (offset << 1),\n      buffer + STRING_HEADER_SIZE,\n      length << 1\n    );\n    store<u32>(buffer, CharCode._0 | (CharCode.DOT << 16), STRING_HEADER_SIZE);\n    for (let i = 2; i < offset; ++i) {\n      store<u16>(buffer + (i << 1), CharCode._0, STRING_HEADER_SIZE);\n    }\n    return length + offset;\n  } else if (length == 1) {\n    // 1e30\n    store<u16>(buffer, CharCode.e, STRING_HEADER_SIZE + 2);\n    length = genExponent(buffer + 4, kk - 1);\n    return length + 2;\n  } else {\n    let len = length << 1;\n    memory.copy(\n      buffer + STRING_HEADER_SIZE + 4,\n      buffer + STRING_HEADER_SIZE + 2,\n      len - 2\n    );\n    store<u16>(buffer,       CharCode.DOT, STRING_HEADER_SIZE + 2);\n    store<u16>(buffer + len, CharCode.e,   STRING_HEADER_SIZE + 2);\n    length += genExponent(buffer + len + 4, kk - 1);\n    return length + 2;\n  }\n}\n\nexport function dtoa_core(buffer: usize, value: f64): i32 {\n  var sign = <i32>(value < 0);\n  if (sign) {\n    value = -value;\n    store<u16>(buffer, CharCode.MINUS, STRING_HEADER_SIZE);\n  }\n  // assert(value > 0 && value <= 1.7976931348623157e308);\n  var len = grisu2(value, buffer, sign);\n      len = prettify(buffer + (sign << 1), len - sign, _K);\n  return len + sign;\n}\n\nexport function dtoa(value: f64): String {\n  if (value == 0) return \"0.0\";\n  if (!isFinite(value)) {\n    if (isNaN(value)) return \"NaN\";\n    return select<String>(\"-Infinity\", \"Infinity\", value < 0);\n  }\n  var buffer = allocateUnsafeString(MAX_DOUBLE_LENGTH);\n  var length = dtoa_core(changetype<usize>(buffer), value);\n  var result = buffer.substring(0, length);\n  freeUnsafeString(buffer);\n  return result;\n}\n\nexport function itoa_stream<T>(buffer: usize, offset: usize, value: T): u32 {\n  buffer += (offset << 1);\n  if (!value) {\n    store<u16>(buffer, CharCode._0, STRING_HEADER_SIZE);\n    return 1;\n  }\n  var decimals: u32 = 0;\n  if (isSigned<T>()) {\n    let sign = value < 0;\n    if (sign) value = -value;\n    if (sizeof<T>() <= 4) {\n      decimals = decimalCount32(value) + <u32>sign;\n      utoa32_core(buffer, value, decimals);\n    } else {\n      if (<u64>value <= <u64>u32.MAX_VALUE) {\n        let val32 = <u32>value;\n        decimals = decimalCount32(val32) + <u32>sign;\n        utoa32_core(buffer, val32, decimals);\n      } else {\n        decimals = decimalCount64(value) + <u32>sign;\n        utoa64_core(buffer, value, decimals);\n      }\n    }\n    if (sign) store<u16>(buffer, CharCode.MINUS, STRING_HEADER_SIZE);\n  } else {\n    if (sizeof<T>() <= 4) {\n      decimals = decimalCount32(value);\n      utoa32_core(buffer, value, decimals);\n    } else {\n      if (<u64>value <= <u64>u32.MAX_VALUE) {\n        let val32 = <u32>value;\n        decimals = decimalCount32(val32);\n        utoa32_core(buffer, val32, decimals);\n      } else {\n        decimals = decimalCount64(value);\n        utoa64_core(buffer, value, decimals);\n      }\n    }\n  }\n  return decimals;\n}\n\nexport function dtoa_stream(buffer: usize, offset: usize, value: f64): u32 {\n  buffer += (offset << 1);\n  if (value == 0.0) {\n    store<u16>(buffer, CharCode._0,  STRING_HEADER_SIZE + 0);\n    store<u16>(buffer, CharCode.DOT, STRING_HEADER_SIZE + 2);\n    store<u16>(buffer, CharCode._0,  STRING_HEADER_SIZE + 4);\n    return 3;\n  }\n  if (!isFinite(value)) {\n    if (isNaN(value)) {\n      store<u16>(buffer, CharCode.N, STRING_HEADER_SIZE + 0);\n      store<u16>(buffer, CharCode.a, STRING_HEADER_SIZE + 2);\n      store<u16>(buffer, CharCode.N, STRING_HEADER_SIZE + 4);\n      return 3;\n    } else {\n      let sign = <i32>(value < 0);\n      let len  = 8 + sign;\n      let source = changetype<usize>(select<String>(\"-Infinity\", \"Infinity\", sign));\n      memory.copy(buffer + STRING_HEADER_SIZE, source + STRING_HEADER_SIZE, len << 1);\n      return len;\n    }\n  }\n  return dtoa_core(buffer, value);\n}\n","/* tslint:disable */\n\n@builtin @inline export const NaN: f64 = 0 / 0;\n@builtin @inline export const Infinity: f64 = 1 / 0;\n\n@builtin export declare function isInteger<T>(value?: T): bool;\n@builtin export declare function isFloat<T>(value?: T): bool;\n@builtin export declare function isSigned<T>(value?: T): bool;\n@builtin export declare function isReference<T>(value?: T): bool;\n@builtin export declare function isString<T>(value?: T): bool;\n@builtin export declare function isArray<T>(value?: T): bool;\n@builtin export declare function isFunction<T>(value?: T): bool;\n@builtin export declare function isNullable<T>(value?: T): bool;\n@builtin export declare function isDefined(expression: void): bool;\n@builtin export declare function isConstant(expression: void): bool;\n@builtin export declare function isManaged<T>(value?: T): bool;\n@inline export function isNaN<T>(value: T): bool { return value != value; }\n@inline export function isFinite<T>(value: T): bool { return value - value == 0; }\n\n@builtin export declare function clz<T>(value: T): T;\n@builtin export declare function ctz<T>(value: T): T;\n@builtin export declare function popcnt<T>(value: T): T;\n@builtin export declare function rotl<T>(value: T, shift: T): T;\n@builtin export declare function rotr<T>(value: T, shift: T): T;\n@builtin export declare function abs<T>(value: T): T;\n@builtin export declare function max<T>(left: T, right: T): T;\n@builtin export declare function min<T>(left: T, right: T): T;\n@builtin export declare function ceil<T>(value: T): T;\n@builtin export declare function floor<T>(value: T): T;\n@builtin export declare function copysign<T>(left: T, right: T): T;\n@builtin export declare function nearest<T>(value: T): T;\n@builtin export declare function reinterpret<T>(value: void): T;\n@builtin export declare function sqrt<T>(value: T): T;\n@builtin export declare function trunc<T>(value: T): T;\n@builtin export declare function load<T>(offset: usize, constantOffset?: usize): T;\n@builtin export declare function store<T>(offset: usize, value: void, constantOffset?: usize): void;\n@builtin export declare function sizeof<T>(): usize; // | u32 / u64\n@builtin export declare function alignof<T>(): usize; // | u32 / u64\n@builtin export declare function offsetof<T>(fieldName?: string): usize; // | u32 / u64\n@builtin export declare function select<T>(ifTrue: T, ifFalse: T, condition: bool): T;\n@builtin export declare function unreachable(): void;\n@builtin export declare function changetype<T>(value: void): T;\n@builtin export declare function assert<T>(isTrueish: T, message?: string): T;\n@builtin export declare function unchecked<T>(expr: T): T;\n@builtin export declare function call_indirect<T>(target: void, ...args: void[]): T;\n@builtin export declare function instantiate<T>(...args: void[]): T;\n\nexport namespace atomic {\n  @builtin export declare function load<T>(offset: usize, constantOffset?: usize): T;\n  @builtin export declare function store<T>(offset: usize, value: void, constantOffset?: usize): void;\n  @builtin export declare function add<T>(ptr: usize, value: T, constantOffset?: usize): T;\n  @builtin export declare function sub<T>(ptr: usize, value: T, constantOffset?: usize): T;\n  @builtin export declare function and<T>(ptr: usize, value: T, constantOffset?: usize): T;\n  @builtin export declare function or<T>(ptr: usize, value: T, constantOffset?: usize): T;\n  @builtin export declare function xor<T>(ptr: usize, value: T, constantOffset?: usize): T;\n  @builtin export declare function xchg<T>(ptr: usize, value: T, constantOffset?: usize): T;\n  @builtin export declare function cmpxchg<T>(ptr: usize, expected:T, replacement: T, constantOffset?: usize): T;\n  @builtin export declare function wait<T>(ptr: usize, expected:T, timeout:i64): i32;\n  @builtin export declare function notify<T>(ptr: usize, count: u32): u32;\n}\n\n@builtin export declare function i8(value: void): i8;\nexport namespace i8 {\n  @lazy export const MIN_VALUE: i8 = -128;\n  @lazy export const MAX_VALUE: i8 =  127;\n}\n\n@builtin export declare function i16(value: void): i16;\nexport namespace i16 {\n  @lazy export const MIN_VALUE: i16 = -32768;\n  @lazy export const MAX_VALUE: i16 =  32767;\n}\n\n@builtin export declare function i32(value: void): i32;\nexport namespace i32 {\n  @lazy export const MIN_VALUE: i32 = -2147483648;\n  @lazy export const MAX_VALUE: i32 =  2147483647;\n  @builtin export declare function clz(value: i32): i32;\n  @builtin export declare function ctz(value: i32): i32;\n  @builtin export declare function popcnt(value: i32): i32;\n  @builtin export declare function rotl(value: i32, shift: i32): i32;\n  @builtin export declare function rotr(value: i32, shift: i32): i32;\n  @builtin export declare function reinterpret_f32(value: f32): i32;\n  @builtin export declare function load8_s(offset: usize, constantOffset?: usize): i32;\n  @builtin export declare function load8_u(offset: usize, constantOffset?: usize): i32;\n  @builtin export declare function load16_s(offset: usize, constantOffset?: usize): i32;\n  @builtin export declare function load16_u(offset: usize, constantOffset?: usize): i32;\n  @builtin export declare function load(offset: usize, constantOffset?: usize): i32;\n  @builtin export declare function store8(offset: usize, value: i32, constantOffset?: usize): void;\n  @builtin export declare function store16(offset: usize, value: i32, constantOffset?: usize): void;\n  @builtin export declare function store(offset: usize, value: i32, constantOffset?: usize): void;\n  \n  export namespace atomic {\n    @builtin export declare function load8_s(offset: usize, constantOffset?: usize): i32;\n    @builtin export declare function load8_u(offset: usize, constantOffset?: usize): i32;\n    @builtin export declare function load16_s(offset: usize, constantOffset?: usize): i32;\n    @builtin export declare function load16_u(offset: usize, constantOffset?: usize): i32;\n    @builtin export declare function load(offset: usize, constantOffset?: usize): i32;\n    @builtin export declare function store8(offset: usize, value: i32, constantOffset?: usize): void;\n    @builtin export declare function store16(offset: usize, value: i32, constantOffset?: usize): void;\n    @builtin export declare function store(offset: usize, value: i32, constantOffset?: usize): void;\n    @builtin export declare function wait(ptr: usize, expected:i32, timeout:i64): i32;\n    @builtin export declare function notify(ptr: usize, count:u32): u32;\n\n    export namespace rmw8_u {\n      @builtin export declare function add(offset: usize, value: i32, constantOffset?: usize): i32;\n      @builtin export declare function sub(offset: usize, value: i32, constantOffset?: usize): i32;\n      @builtin export declare function and(offset: usize, value: i32, constantOffset?: usize): i32;\n      @builtin export declare function or(offset: usize, value: i32, constantOffset?: usize): i32;\n      @builtin export declare function xor(offset: usize, value: i32, constantOffset?: usize): i32;\n      @builtin export declare function xchg(offset: usize, value: i32, constantOffset?: usize): i32;\n      @builtin export declare function cmpxchg(offset: usize, expected:i32, replacement: i32, constantOffset?: usize): i32;\n    }\n\n    export namespace rmw16_u {\n      @builtin export declare function add(offset: usize, value: i32, constantOffset?: usize): i32;\n      @builtin export declare function sub(offset: usize, value: i32, constantOffset?: usize): i32;\n      @builtin export declare function and(offset: usize, value: i32, constantOffset?: usize): i32;\n      @builtin export declare function or(offset: usize, value: i32, constantOffset?: usize): i32;\n      @builtin export declare function xor(offset: usize, value: i32, constantOffset?: usize): i32;\n      @builtin export declare function xchg(offset: usize, value: i32, constantOffset?: usize): i32;\n      @builtin export declare function cmpxchg(offset: usize, expected:i32, replacement: i32, constantOffset?: usize): i32;\n    }\n\n    export namespace rmw {\n      @builtin export declare function add(offset: usize, value: i32, constantOffset?: usize): i32;\n      @builtin export declare function sub(offset: usize, value: i32, constantOffset?: usize): i32;\n      @builtin export declare function and(offset: usize, value: i32, constantOffset?: usize): i32;\n      @builtin export declare function or(offset: usize, value: i32, constantOffset?: usize): i32;\n      @builtin export declare function xor(offset: usize, value: i32, constantOffset?: usize): i32;\n      @builtin export declare function xchg(offset: usize, value: i32, constantOffset?: usize): i32;\n      @builtin export declare function cmpxchg(offset: usize, expected:i32, replacement: i32, constantOffset?: usize): i32;\n    }\n  }\n}\n\n@builtin export declare function i64(value: void): i64;\nexport namespace i64 {\n  @lazy export const MIN_VALUE: i64 = -9223372036854775808;\n  @lazy export const MAX_VALUE: i64 =  9223372036854775807;\n  @builtin export declare function clz(value: i64): i64;\n  @builtin export declare function ctz(value: i64): i64;\n  @builtin export declare function load8_s(offset: usize, constantOffset?: usize): i64;\n  @builtin export declare function load8_u(offset: usize, constantOffset?: usize): u64;\n  @builtin export declare function load16_s(offset: usize, constantOffset?: usize): i64;\n  @builtin export declare function load16_u(offset: usize, constantOffset?: usize): u64;\n  @builtin export declare function load32_s(offset: usize, constantOffset?: usize): i64;\n  @builtin export declare function load32_u(offset: usize, constantOffset?: usize): u64;\n  @builtin export declare function load(offset: usize, constantOffset?: usize): i64;\n  @builtin export declare function popcnt(value: i64): i64;\n  @builtin export declare function rotl(value: i64, shift: i64): i64;\n  @builtin export declare function rotr(value: i64, shift: i64): i64;\n  @builtin export declare function reinterpret_f64(value: f64): i64;\n  @builtin export declare function store8(offset: usize, value: i64, constantOffset?: usize): void;\n  @builtin export declare function store16(offset: usize, value: i64, constantOffset?: usize): void;\n  @builtin export declare function store32(offset: usize, value: i64, constantOffset?: usize): void;\n  @builtin export declare function store(offset: usize, value: i64, constantOffset?: usize): void;\n\n  namespace atomic {\n    @builtin export declare function load8_s(offset: usize, constantOffset?: usize): i64;\n    @builtin export declare function load8_u(offset: usize, constantOffset?: usize): i64;\n    @builtin export declare function load16_s(offset: usize, constantOffset?: usize): i64;\n    @builtin export declare function load16_u(offset: usize, constantOffset?: usize): i64;\n    @builtin export declare function load(offset: usize, constantOffset?: usize): i64;\n    @builtin export declare function store8(offset: usize, value: i64, constantOffset?: usize): void;\n    @builtin export declare function store16(offset: usize, value: i64, constantOffset?: usize): void;\n    @builtin export declare function store(offset: usize, value: i64, constantOffset?: usize): void;\n    @builtin export declare function wait(ptr: usize, expected:i64, timeout:i64): i32;\n    @builtin export declare function notify(ptr: usize, count:u32): u32;\n\n    export namespace rmw8_u {\n      @builtin export declare function add(offset: usize, value: i64, constantOffset?: usize): i64;\n      @builtin export declare function sub(offset: usize, value: i64, constantOffset?: usize): i64;\n      @builtin export declare function and(offset: usize, value: i64, constantOffset?: usize): i64;\n      @builtin export declare function or(offset: usize, value: i64, constantOffset?: usize): i64;\n      @builtin export declare function xor(offset: usize, value: i64, constantOffset?: usize): i64;\n      @builtin export declare function xchg(offset: usize, value: i64, constantOffset?: usize): i64;\n      @builtin export declare function cmpxchg(offset: usize, expected:i64, replacement: i64, constantOffset?: usize): i64;\n    }\n\n    export namespace rmw16_u {\n      @builtin export declare function add(offset: usize, value: i64, constantOffset?: usize): i64;\n      @builtin export declare function sub(offset: usize, value: i64, constantOffset?: usize): i64;\n      @builtin export declare function and(offset: usize, value: i64, constantOffset?: usize): i64;\n      @builtin export declare function or(offset: usize, value: i64, constantOffset?: usize): i64;\n      @builtin export declare function xor(offset: usize, value: i64, constantOffset?: usize): i64;\n      @builtin export declare function xchg(offset: usize, value: i64, constantOffset?: usize): i64;\n      @builtin export declare function cmpxchg(offset: usize, expected:i64, replacement: i64, constantOffset?: usize): i64;\n    }\n\n    export namespace rmw32_u {\n      @builtin export declare function add(offset: usize, value: i64, constantOffset?: usize): i64;\n      @builtin export declare function sub(offset: usize, value: i64, constantOffset?: usize): i64;\n      @builtin export declare function and(offset: usize, value: i64, constantOffset?: usize): i64;\n      @builtin export declare function or(offset: usize, value: i64, constantOffset?: usize): i64;\n      @builtin export declare function xor(offset: usize, value: i64, constantOffset?: usize): i64;\n      @builtin export declare function xchg(offset: usize, value: i64, constantOffset?: usize): i64;\n      @builtin export declare function cmpxchg(offset: usize, expected:i64, replacement: i64, constantOffset?: usize): i64;\n    }\n\n    export namespace rmw {\n      @builtin export declare function add(offset: usize, value: i64, constantOffset?: usize): i64;\n      @builtin export declare function sub(offset: usize, value: i64, constantOffset?: usize): i64;\n      @builtin export declare function and(offset: usize, value: i64, constantOffset?: usize): i64;\n      @builtin export declare function or(offset: usize, value: i64, constantOffset?: usize): i64;\n      @builtin export declare function xor(offset: usize, value: i64, constantOffset?: usize): i64;\n      @builtin export declare function xchg(offset: usize, value: i64, constantOffset?: usize): i64;\n      @builtin export declare function cmpxchg(offset: usize, expected:i64, replacement: i64, constantOffset?: usize): i64;\n    }\n  } \n}\n\n@builtin export declare function isize(value: void): isize;\nexport namespace isize {\n  @lazy export const MIN_VALUE: isize = sizeof<i32>() == sizeof<isize>()\n    ? -2147483648\n    : <isize>-9223372036854775808;\n  @lazy export const MAX_VALUE: isize = sizeof<i32>() == sizeof<isize>()\n    ? 2147483647\n    : <isize>9223372036854775807;\n}\n\n@builtin export declare function u8(value: void): u8;\nexport namespace u8 {\n  @lazy export const MIN_VALUE: u8 = 0;\n  @lazy export const MAX_VALUE: u8 = 255;\n}\n\n@builtin export declare function u16(value: void): u16;\nexport namespace u16 {\n  @lazy export const MIN_VALUE: u16 = 0;\n  @lazy export const MAX_VALUE: u16 = 65535;\n}\n\n@builtin export declare function u32(value: void): u32;\nexport namespace u32 {\n  @lazy export const MIN_VALUE: u32 = 0;\n  @lazy export const MAX_VALUE: u32 = 4294967295;\n}\n\n@builtin export declare function u64(value: void): u64;\nexport namespace u64 {\n  @lazy export const MIN_VALUE: u64 = 0;\n  @lazy export const MAX_VALUE: u64 = 18446744073709551615;\n}\n\n@builtin export declare function usize(value: void): usize;\nexport namespace usize {\n  @lazy export const MIN_VALUE: usize = 0;\n  @lazy export const MAX_VALUE: usize = sizeof<u32>() == sizeof<usize>()\n    ? 4294967295\n    : <usize>18446744073709551615;\n}\n\n@builtin export declare function bool(value: void): bool;\nexport namespace bool {\n  @lazy export const MIN_VALUE: bool = false;\n  @lazy export const MAX_VALUE: bool = true;\n}\n\n@builtin export declare function f32(value: void): f32;\nexport namespace f32 {\n  @lazy export const EPSILON = reinterpret<f32>(0x34000000); // 0x1p-23f\n  @lazy export const MIN_VALUE = reinterpret<f32>(0x00000001); // 0x0.000001p+0f\n  @lazy export const MAX_VALUE = reinterpret<f32>(0x7F7FFFFF); // 0x1.fffffep+127f\n  @lazy export const MIN_NORMAL_VALUE = reinterpret<f32>(0x00800000); // 0x1p-126f\n  @lazy export const MIN_SAFE_INTEGER: f32 = -16777215;\n  @lazy export const MAX_SAFE_INTEGER: f32 =  16777215;\n  @builtin export declare function abs(value: f32): f32;\n  @builtin export declare function ceil(value: f32): f32;\n  @builtin export declare function copysign(x: f32, y: f32): f32;\n  @builtin export declare function floor(value: f32): f32;\n  @builtin export declare function load(offset: usize, constantOffset?: usize): f32;\n  @builtin export declare function max(left: f32, right: f32): f32;\n  @builtin export declare function min(left: f32, right: f32): f32;\n  @builtin export declare function nearest(value: f32): f32;\n  @builtin export declare function reinterpret_i32(value: i32): f32;\n  @builtin export declare function sqrt(value: f32): f32;\n  @builtin export declare function store(offset: usize, value: f32, constantOffset?: usize): void;\n  @builtin export declare function trunc(value: f32): f32;\n}\n\n@builtin export declare function f64(value: void): f64;\nexport namespace f64 {\n  @lazy export const EPSILON = reinterpret<f64>(0x3CB0000000000000); // 0x1p-52\n  @lazy export const MIN_VALUE = reinterpret<f64>(0x0000000000000001); // 0x0.0000000000001p+0\n  @lazy export const MAX_VALUE = reinterpret<f64>(0x7FEFFFFFFFFFFFFF); // 0x1.fffffffffffffp+1023\n  @lazy export const MIN_NORMAL_VALUE = reinterpret<f64>(0x0010000000000000); // 0x1p-1022\n  @lazy export const MIN_SAFE_INTEGER: f64 = -9007199254740991;\n  @lazy export const MAX_SAFE_INTEGER: f64 =  9007199254740991;\n  @builtin export declare function abs(value: f64): f64;\n  @builtin export declare function ceil(value: f64): f64;\n  @builtin export declare function copysign(x: f64, y: f64): f64;\n  @builtin export declare function floor(value: f64): f64;\n  @builtin export declare function load(offset: usize, constantOffset?: usize): f64;\n  @builtin export declare function max(left: f64, right: f64): f64;\n  @builtin export declare function min(left: f64, right: f64): f64;\n  @builtin export declare function nearest(value: f64): f64;\n  @builtin export declare function reinterpret_i64(value: i64): f64;\n  @builtin export declare function sqrt(value: f64): f64;\n  @builtin export declare function store(offset: usize, value: f64, constantOffset?: usize): void;\n  @builtin export declare function trunc(value: f64): f64;\n}\n\n@builtin export declare function start(): void;\n","import {\n  MAX_BLENGTH,\n  HEADER_SIZE,\n  allocateUnsafe,\n  reallocateUnsafe,\n  LOAD,\n  STORE\n} from \"./internal/arraybuffer\";\n\nimport {\n  allocateUnsafe as allocateUnsafeString,\n  freeUnsafe as freeUnsafeString,\n  copyUnsafe as copyUnsafeString\n} from \"./internal/string\";\n\nimport {\n  COMPARATOR,\n  SORT\n} from \"./internal/sort\";\n\nimport {\n  itoa,\n  dtoa,\n  itoa_stream,\n  dtoa_stream,\n  MAX_DOUBLE_LENGTH\n} from \"./internal/number\";\n\nimport {\n  isArray as builtin_isArray\n} from \"./builtins\";\n\nexport class Array<T> {\n  [key: number]: T; // compatibility only\n\n  /* @internal */ buffer_: ArrayBuffer;\n  /* @internal */ length_: i32;\n\n  @inline static isArray<U>(value: U): bool {\n    return builtin_isArray(value) && value !== null;\n  }\n\n  constructor(length: i32 = 0) {\n    const MAX_LENGTH = MAX_BLENGTH >>> alignof<T>();\n    if (<u32>length > <u32>MAX_LENGTH) throw new RangeError(\"Invalid array length\");\n    var byteLength = length << alignof<T>();\n    var buffer = allocateUnsafe(byteLength);\n    this.buffer_ = buffer;\n    this.length_ = length;\n    memory.fill(\n      changetype<usize>(buffer) + HEADER_SIZE,\n      0,\n      <usize>byteLength\n    );\n  }\n\n  @inline\n  get length(): i32 {\n    return this.length_;\n  }\n\n  set length(length: i32) {\n    var buffer = this.buffer_;\n    var capacity = buffer.byteLength >>> alignof<T>();\n    if (<u32>length > <u32>capacity) {\n      const MAX_LENGTH = MAX_BLENGTH >>> alignof<T>();\n      if (<u32>length > <u32>MAX_LENGTH) throw new RangeError(\"Invalid array length\");\n      buffer = reallocateUnsafe(buffer, length << alignof<T>());\n      this.buffer_ = buffer;\n    }\n    this.length_ = length;\n  }\n\n  every(callbackfn: (element: T, index: i32, array: Array<T>) => bool): bool {\n    for (let index = 0, length = this.length_; index < min(length, this.length_); ++index) {\n      if (!callbackfn(LOAD<T>(this.buffer_, index), index, this)) return false;\n    }\n    return true;\n  }\n\n  findIndex(predicate: (element: T, index: i32, array: Array<T>) => bool): i32 {\n    for (let index = 0, length = this.length_; index < min(length, this.length_); ++index) {\n      if (predicate(LOAD<T>(this.buffer_, index), index, this)) return index;\n    }\n    return -1;\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): T {\n    var buffer = this.buffer_;\n    return <u32>index < <u32>(buffer.byteLength >>> alignof<T>())\n      ? LOAD<T>(buffer, index)\n      : <T>unreachable();\n  }\n\n  @operator(\"{}\")\n  private __unchecked_get(index: i32): T {\n    return LOAD<T>(this.buffer_, index);\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: T): void {\n    var buffer = this.buffer_;\n    var capacity = buffer.byteLength >>> alignof<T>();\n    if (<u32>index >= <u32>capacity) {\n      const MAX_LENGTH = MAX_BLENGTH >>> alignof<T>();\n      if (<u32>index >= <u32>MAX_LENGTH) throw new Error(\"Invalid array length\");\n      buffer = reallocateUnsafe(buffer, (index + 1) << alignof<T>());\n      this.buffer_ = buffer;\n      this.length_ = index + 1;\n    }\n    STORE<T>(buffer, index, value);\n    if (isManaged<T>()) __gc_link(changetype<usize>(this), changetype<usize>(value)); // tslint:disable-line\n  }\n\n  @operator(\"{}=\")\n  private __unchecked_set(index: i32, value: T): void {\n    STORE<T>(this.buffer_, index, value);\n    if (isManaged<T>()) __gc_link(changetype<usize>(this), changetype<usize>(value)); // tslint:disable-line\n  }\n\n  fill(value: T, start: i32 = 0, end: i32 = i32.MAX_VALUE): this {\n    var buffer = this.buffer_;\n    var len    = this.length_;\n\n    start = start < 0 ? max(len + start, 0) : min(start, len);\n    end   = end   < 0 ? max(len + end,   0) : min(end,   len);\n\n    if (sizeof<T>() == 1) {\n      if (start < end) {\n        memory.fill(\n          changetype<usize>(buffer) + start + HEADER_SIZE,\n          <u8>value,\n          <usize>(end - start)\n        );\n      }\n    } else {\n      for (; start < end; ++start) {\n        STORE<T>(buffer, start, value);\n      }\n    }\n    return this;\n  }\n\n  @inline\n  includes(searchElement: T, fromIndex: i32 = 0): bool {\n    return this.indexOf(searchElement, fromIndex) >= 0;\n  }\n\n  indexOf(searchElement: T, fromIndex: i32 = 0): i32 {\n    var length = this.length_;\n    if (length == 0 || fromIndex >= length) return -1;\n    if (fromIndex < 0) fromIndex = max(length + fromIndex, 0);\n    var buffer = this.buffer_;\n    while (fromIndex < length) {\n      if (LOAD<T>(buffer, fromIndex) == searchElement) return fromIndex;\n      ++fromIndex;\n    }\n    return -1;\n  }\n\n  lastIndexOf(searchElement: T, fromIndex: i32 = this.length_): i32 {\n    var length = this.length_;\n    if (length == 0) return -1;\n    if (fromIndex < 0) fromIndex = length + fromIndex; // no need to clamp\n    else if (fromIndex >= length) fromIndex = length - 1;\n    var buffer = this.buffer_;\n    while (fromIndex >= 0) {                           // ^\n      if (LOAD<T>(buffer, fromIndex) == searchElement) return fromIndex;\n      --fromIndex;\n    }\n    return -1;\n  }\n\n  push(element: T): i32 {\n    var length = this.length_;\n    var buffer = this.buffer_;\n    var capacity = buffer.byteLength >>> alignof<T>();\n    var newLength = length + 1; // safe only if length is checked\n    if (<u32>length >= <u32>capacity) {\n      const MAX_LENGTH = MAX_BLENGTH >>> alignof<T>();\n      if (<u32>length >= <u32>MAX_LENGTH) throw new Error(\"Invalid array length\");\n      buffer = reallocateUnsafe(buffer, newLength << alignof<T>());\n      this.buffer_ = buffer;\n    }\n    this.length_ = newLength;\n    STORE<T>(buffer, length, element);\n    if (isManaged<T>()) __gc_link(changetype<usize>(this), changetype<usize>(element)); // tslint:disable-line\n    return newLength;\n  }\n\n  concat(items: Array<T>): Array<T> {\n    var thisLen = this.length_;\n    var otherLen = select(0, items.length_, items === null);\n    var outLen = thisLen + otherLen;\n    var out = new Array<T>(outLen);\n\n    if (thisLen) {\n      memory.copy(\n        changetype<usize>(out.buffer_)  + HEADER_SIZE,\n        changetype<usize>(this.buffer_) + HEADER_SIZE,\n        <usize>thisLen << alignof<T>()\n      );\n    }\n    if (otherLen) {\n      memory.copy(\n        changetype<usize>(out.buffer_)   + HEADER_SIZE + (<usize>thisLen << alignof<T>()),\n        changetype<usize>(items.buffer_) + HEADER_SIZE,\n        <usize>otherLen << alignof<T>()\n      );\n    }\n    return out;\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): this {\n    var buffer = this.buffer_;\n    var len = this.length_;\n\n        end   = min<i32>(end, len);\n    var to    = target < 0 ? max(len + target, 0) : min(target, len);\n    var from  = start < 0 ? max(len + start, 0) : min(start, len);\n    var last  = end < 0 ? max(len + end, 0) : min(end, len);\n    var count = min(last - from, len - to);\n\n    if (from < to && to < (from + count)) {\n      from += count - 1;\n      to   += count - 1;\n      while (count) {\n        STORE<T>(buffer, to, LOAD<T>(buffer, from));\n        --from, --to, --count;\n      }\n    } else {\n      memory.copy(\n        changetype<usize>(buffer) + HEADER_SIZE + (<usize>to << alignof<T>()),\n        changetype<usize>(buffer) + HEADER_SIZE + (<usize>from << alignof<T>()),\n        <usize>count << alignof<T>()\n      );\n    }\n    return this;\n  }\n\n  pop(): T {\n    var length = this.length_;\n    if (length < 1) throw new RangeError(\"Array is empty\");\n    var element = LOAD<T>(this.buffer_, --length);\n    this.length_ = length;\n    return element;\n  }\n\n  forEach(callbackfn: (value: T, index: i32, array: Array<T>) => void): void {\n    for (let index = 0, length = this.length_; index < min(length, this.length_); ++index) {\n      callbackfn(LOAD<T>(this.buffer_, index), index, this);\n    }\n  }\n\n  map<U>(callbackfn: (value: T, index: i32, array: Array<T>) => U): Array<U> {\n    var length = this.length_;\n    var result = new Array<U>(length);\n    var buffer = result.buffer_;\n    for (let index = 0; index < min(length, this.length_); ++index) {\n      STORE<U>(buffer, index, callbackfn(LOAD<T>(this.buffer_, index), index, this));\n    }\n    return result;\n  }\n\n  filter(callbackfn: (value: T, index: i32, array: Array<T>) => bool): Array<T> {\n    var result = new Array<T>();\n    for (let index = 0, length = this.length_; index < min(length, this.length_); ++index) {\n      let value = LOAD<T>(this.buffer_, index);\n      if (callbackfn(value, index, this)) result.push(value);\n    }\n    return result;\n  }\n\n  reduce<U>(\n    callbackfn: (previousValue: U, currentValue: T, currentIndex: i32, array: Array<T>) => U,\n    initialValue: U\n  ): U {\n    var accum = initialValue;\n    for (let index = 0, length = this.length_; index < min(length, this.length_); ++index) {\n      accum = callbackfn(accum, LOAD<T>(this.buffer_, index), index, this);\n    }\n    return accum;\n  }\n\n  reduceRight<U>(\n    callbackfn: (previousValue: U, currentValue: T, currentIndex: i32, array: Array<T>) => U,\n    initialValue: U\n  ): U {\n    var accum = initialValue;\n    for (let index = this.length_ - 1; index >= 0; --index) {\n      accum = callbackfn(accum, LOAD<T>(this.buffer_, index), index, this);\n    }\n    return accum;\n  }\n\n  shift(): T {\n    var length = this.length_;\n    if (length < 1) throw new RangeError(\"Array is empty\");\n    var buffer = this.buffer_;\n    var element = LOAD<T>(buffer, 0);\n    var lastIndex = length - 1;\n    memory.copy(\n      changetype<usize>(buffer) + HEADER_SIZE,\n      changetype<usize>(buffer) + HEADER_SIZE + sizeof<T>(),\n      <usize>lastIndex << alignof<T>()\n    );\n    STORE<T>(buffer, lastIndex, <T>null);\n    this.length_ = lastIndex;\n    return element;\n  }\n\n  some(callbackfn: (element: T, index: i32, array: Array<T>) => bool): bool {\n    for (let index = 0, length = this.length_; index < min(length, this.length_); ++index) {\n      if (callbackfn(LOAD<T>(this.buffer_, index), index, this)) return true;\n    }\n    return false;\n  }\n\n  unshift(element: T): i32 {\n    var buffer = this.buffer_;\n    var capacity = buffer.byteLength >>> alignof<T>();\n    var length = this.length_;\n    var newLength = length + 1; // safe only if length is checked\n    if (<u32>length >= <u32>capacity) {\n      const MAX_LENGTH = MAX_BLENGTH >>> alignof<T>();\n      if (<u32>length >= <u32>MAX_LENGTH) throw new Error(\"Invalid array length\");\n      buffer = reallocateUnsafe(buffer, newLength << alignof<T>());\n      capacity = buffer.byteLength >>> alignof<T>();\n      this.buffer_ = buffer;\n    }\n    memory.copy(\n      changetype<usize>(buffer) + HEADER_SIZE + sizeof<T>(),\n      changetype<usize>(buffer) + HEADER_SIZE,\n      <usize>(capacity - 1) << alignof<T>()\n    );\n    STORE<T>(buffer, 0, element);\n    this.length_ = newLength;\n    if (isManaged<T>()) __gc_link(changetype<usize>(this), changetype<usize>(element)); // tslint:disable-line\n    return newLength;\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Array<T> {\n    var len = this.length_;\n    begin = begin < 0 ? max(begin + len, 0) : min(begin, len);\n    end = end < 0 ? max(end + len, 0) : min(end, len);\n    len = end - begin;\n    var sliced = new Array<T>(len);\n    if (len) {\n      memory.copy(\n        changetype<usize>(sliced.buffer_) + HEADER_SIZE,\n        changetype<usize>(this.buffer_) + HEADER_SIZE + (<usize>begin << alignof<T>()),\n        <usize>len << alignof<T>()\n      );\n    }\n    return sliced;\n  }\n\n  splice(start: i32, deleteCount: i32 = i32.MAX_VALUE): Array<T> {\n    var length  = this.length_;\n    start       = start < 0 ? max<i32>(length + start, 0) : min<i32>(start, length);\n    deleteCount = max<i32>(min<i32>(deleteCount, length - start), 0);\n    var buffer  = this.buffer_;\n    var spliced = new Array<T>(deleteCount);\n    var source  = changetype<usize>(buffer) + HEADER_SIZE + (<usize>start << alignof<T>());\n    memory.copy(\n      changetype<usize>(spliced.buffer_) + HEADER_SIZE,\n      source,\n      <usize>deleteCount << alignof<T>()\n    );\n    var offset = start + deleteCount;\n    if (length != offset) {\n      memory.copy(\n        source,\n        changetype<usize>(buffer) + HEADER_SIZE + (<usize>offset << alignof<T>()),\n        <usize>(length - offset) << alignof<T>()\n      );\n    }\n    this.length_ = length - deleteCount;\n    return spliced;\n  }\n\n  reverse(): Array<T> {\n    var buffer = this.buffer_;\n    for (let front = 0, back = this.length_ - 1; front < back; ++front, --back) {\n      let temp = LOAD<T>(buffer, front);\n      STORE<T>(buffer, front, LOAD<T>(buffer, back));\n      STORE<T>(buffer, back, temp);\n    }\n    return this;\n  }\n\n  sort(comparator: (a: T, b: T) => i32 = COMPARATOR<T>()): this {\n    // TODO remove this when flow will allow trackcing null\n    assert(comparator); // The comparison function must be a function\n\n    var length = this.length_;\n    if (length <= 1) return this;\n    var buffer = this.buffer_;\n    if (length == 2) {\n      let a = LOAD<T>(buffer, 1); // a = arr[1]\n      let b = LOAD<T>(buffer, 0); // b = arr[0]\n      if (comparator(a, b) < 0) {\n        STORE<T>(buffer, 1, b);   // arr[1] = b;\n        STORE<T>(buffer, 0, a);   // arr[0] = a;\n      }\n      return this;\n    }\n    SORT<T>(buffer, 0, length, comparator);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    var lastIndex = this.length_ - 1;\n    if (lastIndex < 0) return \"\";\n    var result = \"\";\n    var value: T;\n    var buffer = this.buffer_;\n    var sepLen = separator.length;\n    var hasSeparator = sepLen != 0;\n    if (value instanceof bool) {\n      if (!lastIndex) return select<string>(\"true\", \"false\", LOAD<T,bool>(buffer, 0));\n\n      let valueLen = 5; // max possible length of element len(\"false\")\n      let estLen = (valueLen + sepLen) * lastIndex + valueLen;\n      let result = allocateUnsafeString(estLen);\n      let offset = 0;\n      for (let i = 0; i < lastIndex; ++i) {\n        value = LOAD<T,bool>(buffer, i);\n        valueLen = 4 + <i32>(!value);\n        copyUnsafeString(result, offset, select<string>(\"true\", \"false\", value), 0, valueLen);\n        offset += valueLen;\n        if (hasSeparator) {\n          copyUnsafeString(result, offset, changetype<String>(separator), 0, sepLen);\n          offset += sepLen;\n        }\n      }\n      value = LOAD<T,bool>(buffer, lastIndex);\n      valueLen = 4 + <i32>(!value);\n      copyUnsafeString(result, offset, select<string>(\"true\", \"false\", value), 0, valueLen);\n      offset += valueLen;\n\n      let out = result;\n      if (estLen > offset) {\n        out = result.substring(0, offset);\n        freeUnsafeString(result);\n      }\n      return out;\n    } else if (isInteger<T>()) {\n      if (!lastIndex) return changetype<string>(itoa<T>(LOAD<T>(buffer, 0)));\n\n      const valueLen = (sizeof<T>() <= 4 ? 10 : 20) + <i32>isSigned<T>();\n      let estLen = (valueLen + sepLen) * lastIndex + valueLen;\n      let result = allocateUnsafeString(estLen);\n      let offset = 0;\n      for (let i = 0; i < lastIndex; ++i) {\n        value = LOAD<T>(buffer, i);\n        offset += itoa_stream<T>(changetype<usize>(result), offset, value);\n        if (hasSeparator) {\n          copyUnsafeString(result, offset, separator, 0, sepLen);\n          offset += sepLen;\n        }\n      }\n      value = LOAD<T>(buffer, lastIndex);\n      offset += itoa_stream<T>(changetype<usize>(result), offset, value);\n      let out = result;\n      if (estLen > offset) {\n        out = result.substring(0, offset);\n        freeUnsafeString(result);\n      }\n      return out;\n    } else if (isFloat<T>()) {\n      if (!lastIndex) return changetype<string>(dtoa(LOAD<T,f64>(buffer, 0)));\n\n      const valueLen = MAX_DOUBLE_LENGTH;\n      let estLen = (valueLen + sepLen) * lastIndex + valueLen;\n      let result = allocateUnsafeString(estLen);\n      let offset = 0;\n      for (let i = 0; i < lastIndex; ++i) {\n        value = LOAD<T,f64>(buffer, i);\n        offset += dtoa_stream(changetype<usize>(result), offset, value);\n        if (hasSeparator) {\n          copyUnsafeString(result, offset, separator, 0, sepLen);\n          offset += sepLen;\n        }\n      }\n      value = LOAD<T,f64>(buffer, lastIndex);\n      offset += dtoa_stream(changetype<usize>(result), offset, value);\n      let out = result;\n      if (estLen > offset) {\n        out = result.substring(0, offset);\n        freeUnsafeString(result);\n      }\n      return out;\n    } else if (isString<T>()) {\n      if (!lastIndex) return LOAD<string>(buffer, 0);\n\n      let estLen = 0;\n      for (let i = 0, len = lastIndex + 1; i < len; ++i) {\n        estLen += LOAD<string>(buffer, i).length;\n      }\n      let offset = 0;\n      let result = allocateUnsafeString(estLen + sepLen * lastIndex);\n      for (let i = 0; i < lastIndex; ++i) {\n        value = LOAD<string>(buffer, i);\n        if (value) {\n          let valueLen = value.length;                          // tslint:disable-line:no-unsafe-any\n          copyUnsafeString(result, offset, value, 0, valueLen); // tslint:disable-line:no-unsafe-any\n          offset += valueLen;                                   // tslint:disable-line:no-unsafe-any\n        }\n        if (hasSeparator) {\n          copyUnsafeString(result, offset, separator, 0, sepLen);\n          offset += sepLen;\n        }\n      }\n      value = LOAD<string>(buffer, lastIndex);\n      if (value) {\n        let valueLen = value.length;                          // tslint:disable-line:no-unsafe-any\n        copyUnsafeString(result, offset, value, 0, valueLen); // tslint:disable-line:no-unsafe-any\n      }\n      return result;\n    } else if (isArray<T>()) {\n      if (!lastIndex) {\n        value = LOAD<T>(buffer, 0);\n        return value ? value.join(separator) : \"\"; // tslint:disable-line:no-unsafe-any\n      }\n      for (let i = 0; i < lastIndex; ++i) {\n        value = LOAD<T>(buffer, i);\n        if (value) result += value.join(separator); // tslint:disable-line:no-unsafe-any\n        if (hasSeparator) result += separator;\n      }\n      value = LOAD<T>(buffer, lastIndex);\n      if (value) result += value.join(separator); // tslint:disable-line:no-unsafe-any\n      return result;\n    } else if (isReference<T>()) { // References\n      if (!lastIndex) return \"[object Object]\";\n      const valueLen = 15; // max possible length of element len(\"[object Object]\")\n      let estLen = (valueLen + sepLen) * lastIndex + valueLen;\n      let result = allocateUnsafeString(estLen);\n      let offset = 0;\n      for (let i = 0; i < lastIndex; ++i) {\n        value = LOAD<T>(buffer, i);\n        if (value) {\n          copyUnsafeString(result, offset, changetype<String>(\"[object Object]\"), 0, valueLen);\n          offset += valueLen;\n        }\n        if (hasSeparator) {\n          copyUnsafeString(result, offset, changetype<String>(separator), 0, sepLen);\n          offset += sepLen;\n        }\n      }\n      if (LOAD<T>(buffer, lastIndex)) {\n        copyUnsafeString(result, offset, changetype<String>(\"[object Object]\"), 0, valueLen);\n        offset += valueLen;\n      }\n      let out = result;\n      if (estLen > offset) {\n        out = result.substring(0, offset);\n        freeUnsafeString(result);\n      }\n      return out;\n    } else {\n      assert(false); // Unsupported generic typename\n    }\n  }\n\n  @inline\n  toString(): string {\n    return this.join();\n  }\n\n  private __gc(): void {\n    var buffer = this.buffer_;\n    __gc_mark(changetype<usize>(buffer)); // tslint:disable-line\n    if (isManaged<T>()) {\n      let offset: usize = 0;\n      let end = <usize>this.length_ << alignof<usize>();\n      while (offset < end) {\n        __gc_mark(load<usize>(changetype<usize>(buffer) + offset, HEADER_SIZE)); // tslint:disable-line\n        offset += sizeof<usize>();\n      }\n    }\n  }\n}\n","import { memcmp, memmove, memset } from \"./internal/memory\";\n\n@builtin export declare const HEAP_BASE: usize; // tslint:disable-line\n\n/* tslint:disable */\n\nexport namespace memory {\n\n  @builtin export declare function size(): i32;\n\n  @builtin export declare function grow(pages: i32): i32;\n\n  @builtin @inline\n  export function fill(dest: usize, c: u8, n: usize): void { // see: musl/src/string/memset\n    memset(dest, c, n); // fallback if \"bulk-memory\" isn't enabled\n  }\n\n  @builtin @inline\n  export function copy(dest: usize, src: usize, n: usize): void { // see: musl/src/string/memmove.c\n    memmove(dest, src, n); // fallback if \"bulk-memory\" isn't enabled\n  }\n\n  @inline export function compare(vl: usize, vr: usize, n: usize): i32 { // see: musl/src/string/memcmp.c\n    return memcmp(vl, vr, n);\n  }\n\n  // Passive segments\n\n  // export function init(segmentIndex: u32, srcOffset: usize, dstOffset: usize, n: usize): void {\n  //   __memory_init(segmentIndex, srcOffset, dstOffset);\n  // }\n\n  // export function drop(segmentIndex: u32): void {\n  //   __memory_drop(segmentIndex);\n  // }\n\n  // Allocator\n\n  @inline export function allocate(size: usize): usize {\n    if (isDefined(__memory_allocate)) return __memory_allocate(size);\n    WARNING(\"Calling 'memory.allocate' requires a memory manager to be present.\");\n    return <usize>unreachable();\n  }\n\n  @inline export function free(ptr: usize): void {\n    if (isDefined(__memory_free)) { __memory_free(ptr); return; }\n    WARNING(\"Calling 'memory.free' requires a memory manager to be present.\");\n    unreachable();\n  }\n\n  @inline export function reset(): void {\n    if (isDefined(__memory_reset)) { __memory_reset(); return; }\n    unreachable();\n  }\n}\n","// this function will go away once `memory.copy` becomes an intrinsic\nexport function memcpy(dest: usize, src: usize, n: usize): void { // see: musl/src/string/memcpy.c\n  var w: u32, x: u32;\n\n  // copy 1 byte each until src is aligned to 4 bytes\n  while (n && (src & 3)) {\n    store<u8>(dest++, load<u8>(src++));\n    n--;\n  }\n\n  // if dst is aligned to 4 bytes as well, copy 4 bytes each\n  if ((dest & 3) == 0) {\n    while (n >= 16) {\n      store<u32>(dest     , load<u32>(src     ));\n      store<u32>(dest +  4, load<u32>(src +  4));\n      store<u32>(dest +  8, load<u32>(src +  8));\n      store<u32>(dest + 12, load<u32>(src + 12));\n      src += 16; dest += 16; n -= 16;\n    }\n    if (n & 8) {\n      store<u32>(dest    , load<u32>(src    ));\n      store<u32>(dest + 4, load<u32>(src + 4));\n      dest += 8; src += 8;\n    }\n    if (n & 4) {\n      store<u32>(dest, load<u32>(src));\n      dest += 4; src += 4;\n    }\n    if (n & 2) { // drop to 2 bytes each\n      store<u16>(dest, load<u16>(src));\n      dest += 2; src += 2;\n    }\n    if (n & 1) { // drop to 1 byte\n      store<u8>(dest++, load<u8>(src++));\n    }\n    return;\n  }\n\n  // if dst is not aligned to 4 bytes, use alternating shifts to copy 4 bytes each\n  // doing shifts if faster when copying enough bytes (here: 32 or more)\n  if (n >= 32) {\n    switch (dest & 3) {\n      // known to be != 0\n      case 1: {\n        w = load<u32>(src);\n        store<u8>(dest++, load<u8>(src++));\n        store<u8>(dest++, load<u8>(src++));\n        store<u8>(dest++, load<u8>(src++));\n        n -= 3;\n        while (n >= 17) {\n          x = load<u32>(src + 1);\n          store<u32>(dest, w >> 24 | x << 8);\n          w = load<u32>(src + 5);\n          store<u32>(dest + 4, x >> 24 | w << 8);\n          x = load<u32>(src + 9);\n          store<u32>(dest + 8, w >> 24 | x << 8);\n          w = load<u32>(src + 13);\n          store<u32>(dest + 12, x >> 24 | w << 8);\n          src += 16; dest += 16; n -= 16;\n        }\n        break;\n      }\n      case 2: {\n        w = load<u32>(src);\n        store<u8>(dest++, load<u8>(src++));\n        store<u8>(dest++, load<u8>(src++));\n        n -= 2;\n        while (n >= 18) {\n          x = load<u32>(src + 2);\n          store<u32>(dest, w >> 16 | x << 16);\n          w = load<u32>(src + 6);\n          store<u32>(dest + 4, x >> 16 | w << 16);\n          x = load<u32>(src + 10);\n          store<u32>(dest + 8, w >> 16 | x << 16);\n          w = load<u32>(src + 14);\n          store<u32>(dest + 12, x >> 16 | w << 16);\n          src += 16; dest += 16; n -= 16;\n        }\n        break;\n      }\n      case 3: {\n        w = load<u32>(src);\n        store<u8>(dest++, load<u8>(src++));\n        n -= 1;\n        while (n >= 19) {\n          x = load<u32>(src + 3);\n          store<u32>(dest, w >> 8 | x << 24);\n          w = load<u32>(src + 7);\n          store<u32>(dest + 4, x >> 8 | w << 24);\n          x = load<u32>(src + 11);\n          store<u32>(dest + 8, w >> 8 | x << 24);\n          w = load<u32>(src + 15);\n          store<u32>(dest + 12, x >> 8 | w << 24);\n          src += 16; dest += 16; n -= 16;\n        }\n        break;\n      }\n    }\n  }\n\n  // copy remaining bytes one by one\n  if (n & 16) {\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n  }\n  if (n & 8) {\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n  }\n  if (n & 4) {\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n  }\n  if (n & 2) {\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n  }\n  if (n & 1) {\n    store<u8>(dest++, load<u8>(src++));\n  }\n}\n\n// this function will go away once `memory.copy` becomes an intrinsic\nexport function memmove(dest: usize, src: usize, n: usize): void { // see: musl/src/string/memmove.c\n  if (dest === src) return;\n  if (src + n <= dest || dest + n <= src) {\n    memcpy(dest, src, n);\n    return;\n  }\n  if (dest < src) {\n    if ((src & 7) == (dest & 7)) {\n      while (dest & 7) {\n        if (!n) return;\n        --n;\n        store<u8>(dest++, load<u8>(src++));\n      }\n      while (n >= 8) {\n        store<u64>(dest, load<u64>(src));\n        n    -= 8;\n        dest += 8;\n        src  += 8;\n      }\n    }\n    while (n) {\n      store<u8>(dest++, load<u8>(src++));\n      --n;\n    }\n  } else {\n    if ((src & 7) == (dest & 7)) {\n      while ((dest + n) & 7) {\n        if (!n) return;\n        store<u8>(dest + --n, load<u8>(src + n));\n      }\n      while (n >= 8) {\n        n -= 8;\n        store<u64>(dest + n, load<u64>(src + n));\n      }\n    }\n    while (n) {\n      store<u8>(dest + --n, load<u8>(src + n));\n    }\n  }\n}\n\n// this function will go away once `memory.fill` becomes an intrinsic\nexport function memset(dest: usize, c: u8, n: usize): void { // see: musl/src/string/memset\n\n  // fill head and tail with minimal branching\n  if (!n) return;\n  store<u8>(dest, c);\n  store<u8>(dest + n - 1, c);\n  if (n <= 2) return;\n\n  store<u8>(dest + 1, c);\n  store<u8>(dest + 2, c);\n  store<u8>(dest + n - 2, c);\n  store<u8>(dest + n - 3, c);\n  if (n <= 6) return;\n  store<u8>(dest + 3, c);\n  store<u8>(dest + n - 4, c);\n  if (n <= 8) return;\n\n  // advance pointer to align it at 4-byte boundary\n  var k: usize = -dest & 3;\n  dest += k;\n  n -= k;\n  n &= -4;\n\n  var c32: u32 = <u32>-1 / 255 * c;\n\n  // fill head/tail up to 28 bytes each in preparation\n  store<u32>(dest, c32);\n  store<u32>(dest + n - 4, c32);\n  if (n <= 8) return;\n  store<u32>(dest + 4, c32);\n  store<u32>(dest + 8, c32);\n  store<u32>(dest + n - 12, c32);\n  store<u32>(dest + n - 8, c32);\n  if (n <= 24) return;\n  store<u32>(dest + 12, c32);\n  store<u32>(dest + 16, c32);\n  store<u32>(dest + 20, c32);\n  store<u32>(dest + 24, c32);\n  store<u32>(dest + n - 28, c32);\n  store<u32>(dest + n - 24, c32);\n  store<u32>(dest + n - 20, c32);\n  store<u32>(dest + n - 16, c32);\n\n  // align to a multiple of 8\n  k = 24 + (dest & 4);\n  dest += k;\n  n -= k;\n\n  // copy 32 bytes each\n  var c64: u64 = <u64>c32 | (<u64>c32 << 32);\n  while (n >= 32) {\n    store<u64>(dest, c64);\n    store<u64>(dest + 8, c64);\n    store<u64>(dest + 16, c64);\n    store<u64>(dest + 24, c64);\n    n -= 32;\n    dest += 32;\n  }\n}\n\nexport function memcmp(vl: usize, vr: usize, n: usize): i32 { // see: musl/src/string/memcmp.c\n  if (vl == vr) return 0;\n  while (n != 0 && load<u8>(vl) == load<u8>(vr)) {\n    n--; vl++; vr++;\n  }\n  return n ? <i32>load<u8>(vl) - <i32>load<u8>(vr) : 0;\n}\n","import { RangeDecoder } from './range-decoder';\nimport { LZMA } from './lzma';\n\n/**\n * LZMA Decoder\n * @author Nidin Vinayakan\n */\nexport class BitTreeDecoder {\n    public probs: u16[]\n    private numBits: i32\n\n    constructor(numBits:i32) {\n        this.numBits = numBits\n        this.probs = new Array<u16>(1 << this.numBits)\n    }\n    public init(): void {\n        LZMA.INIT_PROBS(this.probs)\n    }\n    public decode(rc: RangeDecoder): i32 {\n        var m: i32 = 1 //Uint16\n        for (var i: i32 = 0; i < this.numBits; i++) m = (m << 1) + rc.decodeBit(this.probs, m)\n        return m - (1 << this.numBits)\n    }\n    public reverseDecode(rc: RangeDecoder): i32 {\n        return LZMA.BitTreeReverseDecode(this.probs, this.numBits, rc)\n    }\n    static constructArray(numBits: i32, len: i32): Array<BitTreeDecoder> {\n        var vec: BitTreeDecoder[] = new Array<BitTreeDecoder>(len)\n        for (var i: i32 = 0; i < len; i++) {\n            vec[i] = new BitTreeDecoder(numBits)\n        }\n        return vec\n    }\n}\n","import { BitTreeDecoder } from './bit-tree-decoder'\nimport { LZMA } from './lzma'\nimport { RangeDecoder } from './range-decoder'\n\n/**\n * LZMA Decoder\n * @author Nidin Vinayakan\n */\n\nexport class LenDecoder {\n    private choice: u16[]\n    private lowCoder: Array<BitTreeDecoder> //3\n    private midCoder: Array<BitTreeDecoder> //3\n    private highCoder: BitTreeDecoder //8\n\n    constructor() {\n        this.lowCoder = BitTreeDecoder.constructArray(3, 1 << LZMA.kNumPosBitsMax)\n        this.midCoder = BitTreeDecoder.constructArray(3, 1 << LZMA.kNumPosBitsMax)\n        this.highCoder = new BitTreeDecoder(8)\n    }\n\n    public init(): void {\n        this.choice = [LZMA.PROB_INIT_VAL, LZMA.PROB_INIT_VAL]\n        this.highCoder.init()\n        for (var i: i32 = 0; i < 1 << LZMA.kNumPosBitsMax; i++) {\n            this.lowCoder[i].init()\n            this.midCoder[i].init()\n        }\n    }\n    public decode(rc: RangeDecoder, posState: i32): i32 {\n        if (rc.decodeBit(this.choice, 0) == 0) {\n            return this.lowCoder[posState].decode(rc)\n        }\n        if (rc.decodeBit(this.choice, 1) == 0) {\n            return 8 + this.midCoder[posState].decode(rc)\n        }\n        return 16 + this.highCoder.decode(rc)\n    }\n}\n","/**\n * LZMA Decoder\n * @author Nidin Vinayakan\n */\n\nexport class OutWindow {\n    public totalPos: i32\n    public outStream: Uint8Array\n\n    private buf: Uint8Array\n    private pos: i32\n    public out_pos: i32\n    private size: i32\n    private isFull: boolean\n\n    constructor() {\n        this.out_pos = 0\n    }\n    public create(\n        dictSize: i32, //UInt32\n    ): void {\n        this.buf = new Uint8Array(dictSize)\n        this.pos = 0\n        this.size = dictSize\n        this.isFull = false\n        this.totalPos = 0\n    }\n\n    public putByte(b: i32): void {\n        this.totalPos++\n        this.buf[this.pos++] = b\n        if (this.pos == this.size) {\n            this.pos = 0\n            this.isFull = true\n        }\n        this.outStream[this.out_pos++] = b\n    }\n\n    public getByte(\n        dist: i32, //UInt32\n    ): i32 {\n        return this.buf[dist <= this.pos ? this.pos - dist : this.size - dist + this.pos]\n    }\n\n    public copyMatch(\n        dist: i32,\n        len:i32, //UInt32 ,unsigned byte\n    ): void {\n        for (; len > 0; len--) {\n            this.putByte(this.getByte(dist))\n        }\n    }\n\n    public checkDistance(dist: i32): boolean {\n        //UInt32\n        return dist <= this.pos || this.isFull\n    }\n\n    public isEmpty(): boolean {\n        return this.pos == 0 && !this.isFull\n    }\n}\n","import { LZMA } from './lzma/lzma'\r\n\r\nvar lzma = new LZMA()\r\nexport function decode(data: Uint8Array):Uint8Array {\r\n  return lzma.decode(data)\r\n}\r\n","import {\n  HEADER_SIZE as AB_HEADER_SIZE,\n  MAX_BLENGTH as AB_MAX_BLENGTH,\n  allocateUnsafe,\n  LOAD,\n  STORE\n} from \"./arraybuffer\";\n\nimport {\n  SORT as SORT_IMPL\n} from \"./sort\";\n\n/** Typed array base class. Not a global object. */\nexport abstract class TypedArray<T> {\n  [key: number]: T; // compatibility only\n\n  readonly buffer: ArrayBuffer;\n  readonly byteOffset: i32;\n  readonly byteLength: i32;\n\n  constructor(length: i32) {\n    const MAX_LENGTH = <u32>AB_MAX_BLENGTH / sizeof<T>();\n    if (<u32>length > MAX_LENGTH) throw new RangeError(\"Invalid typed array length\");\n    var byteLength = length << alignof<T>();\n    var buffer = allocateUnsafe(byteLength);\n    memory.fill(changetype<usize>(buffer) + AB_HEADER_SIZE, 0, <usize>byteLength);\n    this.buffer = buffer;\n    this.byteOffset = 0;\n    this.byteLength = byteLength;\n  }\n\n  @inline\n  get length(): i32 {\n    return this.byteLength >>> alignof<T>();\n  }\n\n  @operator(\"[]\")\n  protected __get(index: i32): T {\n    if (<u32>index >= <u32>(this.byteLength >>> alignof<T>())) throw new Error(\"Index out of bounds\");\n    return LOAD<T>(this.buffer, index, this.byteOffset);\n  }\n\n  @inline @operator(\"{}\")\n  protected __unchecked_get(index: i32): T {\n    return LOAD<T>(this.buffer, index, this.byteOffset);\n  }\n\n  @operator(\"[]=\")\n  protected __set(index: i32, value: native<T>): void {\n    if (<u32>index >= <u32>(this.byteLength >>> alignof<T>())) throw new Error(\"Index out of bounds\");\n    STORE<T,native<T>>(this.buffer, index, value, this.byteOffset);\n  }\n\n  @inline @operator(\"{}=\")\n  protected __unchecked_set(index: i32, value: native<T>): void {\n    STORE<T,native<T>>(this.buffer, index, value, this.byteOffset);\n  }\n\n  // copyWithin(target: i32, start: i32, end: i32 = this.length): this\n}\n\n@inline\nexport function FILL<TArray extends TypedArray<T>, T extends number>(\n  array: TArray,\n  value: native<T>,\n  start: i32,\n  end: i32\n): TArray {\n  var buffer = array.buffer;\n  var byteOffset = array.byteOffset;\n  var len = array.length;\n  start = start < 0 ? max(len + start, 0) : min(start, len);\n  end   = end   < 0 ? max(len + end,   0) : min(end,   len);\n  if (sizeof<T>() == 1) {\n    if (start < end) {\n      memory.fill(\n        changetype<usize>(buffer) + start + byteOffset + AB_HEADER_SIZE,\n        <u8>value,\n        <usize>(end - start)\n      );\n    }\n  } else {\n    for (; start < end; ++start) {\n      STORE<T,native<T>>(buffer, start, value, byteOffset);\n    }\n  }\n  return array;\n}\n\n@inline\nexport function SORT<TArray extends TypedArray<T>, T>(\n  array: TArray,\n  comparator: (a: T, b: T) => i32\n): TArray {\n  var byteOffset = array.byteOffset;\n  var length = array.length;\n  if (length <= 1) return array;\n  var buffer = array.buffer;\n  if (length == 2) {\n    let a = LOAD<T>(buffer, 1, byteOffset);\n    let b = LOAD<T>(buffer, 0, byteOffset);\n    if (comparator(a, b) < 0) {\n      STORE<T>(buffer, 1, b, byteOffset);\n      STORE<T>(buffer, 0, a, byteOffset);\n    }\n    return array;\n  }\n  SORT_IMPL<T>(buffer, byteOffset, length, comparator);\n  return array;\n}\n\n@inline\nexport function SUBARRAY<TArray extends TypedArray<T>, T>(\n  array: TArray,\n  begin: i32,\n  end: i32\n): TArray {\n  var length = <i32>array.length;\n  if (begin < 0) begin = max(length + begin, 0);\n  else begin = min(begin, length);\n  if (end < 0) end = max(length + end, begin);\n  else end = max(min(end, length), begin);\n  var slice = memory.allocate(offsetof<TArray>());\n  store<usize>(slice, array.buffer, offsetof<TArray>(\"buffer\"));\n  store<i32>(slice, <i32>array.byteOffset + (begin << alignof<T>()), offsetof<TArray>(\"byteOffset\"));\n  store<i32>(slice, (end - begin) << alignof<T>(), offsetof<TArray>(\"byteLength\"));\n  return changetype<TArray>(slice);\n}\n\n@inline\nexport function REDUCE<TArray extends TypedArray<T>, T, TRet>(\n  array: TArray,\n  callbackfn: (accumulator: TRet, value: T, index: i32, array: TArray) => TRet,\n  initialValue: TRet\n): TRet {\n  var length = array.length;\n  var buffer = array.buffer;\n  var byteOffset = array.byteOffset;\n  for (let i = 0; i < length; i++) {\n    initialValue = callbackfn(\n      initialValue,\n      LOAD<T>(buffer, i, byteOffset),\n      i,\n      array,\n    );\n  }\n  return initialValue;\n}\n\n@inline\nexport function REDUCE_RIGHT<TArray extends TypedArray<T>, T, TRet>(\n  array: TArray,\n  callbackfn: (accumulator: TRet, value: T, index: i32, array: TArray) => TRet,\n  initialValue: TRet\n): TRet {\n  var buffer = array.buffer;\n  var byteOffset = array.byteOffset;\n  for (let i = array.length - 1; i >= 0; i--) {\n    initialValue = callbackfn(\n      initialValue,\n      LOAD<T>(buffer, i, byteOffset),\n      i,\n      array,\n    );\n  }\n  return initialValue;\n}\n\n@inline\nexport function MAP<TArray extends TypedArray<T>, T>(\n  array: TArray,\n  callbackfn: (value: T, index: i32, self: TArray) => T,\n): TArray {\n  var length = array.length;\n  var buffer = array.buffer;\n  var byteOffset = array.byteOffset;\n  var result = instantiate<TArray>(length);\n  var resultBuffer = result.buffer;\n  for (let i = 0; i < length; i++) {\n    STORE<T, native<T>>(resultBuffer, i, <native<T>>callbackfn(LOAD<T>(buffer, i, byteOffset), i, array));\n  }\n\n  return result;\n}\n\n@inline\nexport function FIND_INDEX<TArray extends TypedArray<T>, T>(\n  array: TArray,\n  callbackfn: (value: T, index: i32, array: TArray) => bool,\n): i32 {\n  var length = array.length;\n  var buffer = array.buffer;\n  var byteOffset = array.byteOffset;\n  for (let i = 0; i < length; i++) {\n    if (callbackfn(LOAD<T>(buffer, i, byteOffset), i, array)) {\n      return i;\n    }\n  }\n  return -1;\n}\n\n@inline\nexport function SOME<TArray extends TypedArray<T>, T>(\n  array: TArray,\n  callbackfn: (value: T, index: i32, array: TArray) => bool,\n): bool {\n  var length = array.length;\n  var buffer = array.buffer;\n  var byteOffset = array.byteOffset;\n  for (let i = 0; i < length; i++) {\n    if (callbackfn(LOAD<T>(buffer, i, byteOffset), i, array)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n@inline\nexport function EVERY<TArray extends TypedArray<T>, T>(\n  array: TArray,\n  callbackfn: (value: T, index: i32, array: TArray) => bool,\n): bool {\n  var length = array.length;\n  var buffer = array.buffer;\n  var byteOffset = array.byteOffset;\n  for (let i = 0; i < length; i++) {\n    if (callbackfn(LOAD<T>(buffer, i, byteOffset), i, array)) {\n      continue;\n    }\n    return false;\n  }\n  return true;\n}\n"]}